-- Load Rayfield UI
local Rayfield = loadstring(game:HttpGet("https://sirius.menu/rayfield"))()

-- Initial notification
game:GetService("StarterGui"):SetCore("SendNotification", {
    Title = "Universal Hitbox Expander",
    Text = "Made By Corygunzjr",
    Duration = 5
})

-- UI Setup
local Window = Rayfield:CreateWindow({  -- Fixed typo here (was :极Window)
    Name = "Universal Hitbox Expander",
    LoadingTitle = "Loading HBE...",
    LoadingSubtitle = "With Team/Player Selection & Multi-Hitbox",
    ConfigurationSaving = {
        Enabled = true,
        FolderName = "RayfieldHBE",
        FileName = "HBEConfig"
    },
    Discord = { Enabled = false },
    KeySystem = false
})

-- Create tabs
local MainTab = Window:CreateTab("Hitbox Expander", 4483362458)
local FilterTab = Window:CreateTab("Filters", 4483362458)
local ScriptTab = Window:Create极Tab("Script", 4483362458)
local EspTab = Window:CreateTab("ESP", 4483362458)  -- New ESP tab

-- Services
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local LocalPlayer = Players.LocalPlayer
local Workspace = game:GetService("Workspace")
local Teams = game:GetService("Teams")

-- Configuration system
local config = {
    size = 5,
    transparency = 0.5,
    enabled = false,
    npcEnabled = false,
    npcSize = 5,
    npcTransparency = 0.5
}

-- Filter system
local filters = {
    excludedPlayers = {},
    excludedTeams = {},
    forceIncludedPlayers = {},
    hideWhenSitting = false,
    hideFriends = false,
    hideForceField = false
}

-- Hitbox toggle config
local hitboxToggles = {
    Head = true,
    ["Left Arm"] = false,
    ["Right Arm"] = false,
    ["Left Leg"] = false,
    ["Right Leg"] = false,
    Torso = false,
}

-- Player monitoring
local monitoredPlayers = {}
-- NPC monitoring system
local npcTracker = {
    activeNPCs = {},
    connections = {}
}

-- Mapping of hitbox type to body parts
local hitboxPartsMap = {
    Head = {"Head"},
    ["Left Arm"] = {"LeftLowerArm", "LeftUpperArm"},
    ["Right Arm"] = {"RightLowerArm", "RightUpperArm"},
    ["Left Leg"] = {"LeftLowerLeg", "LeftUpper极"},
    ["Right Leg"] = {"RightLowerLeg", "RightUpperLeg"},
    Torso = {"Torso", "UpperTorso", "LowerTorso"}
}

-- ESP Configuration
local espConfig = {
    enabled = false,
    highlightPlayers = true,
    showNames = true,
    showHealth = true,
    showItems = false,
    highlightColor = Color3.new(1, 0, 0),
    nameColor = Color3.new(1, 1, 1),
    healthColor = Color3.new(0, 1, 0),
    nameSize = 14,
    itemColor = Color3.new(0, 1, 0),
    itemNames = {"Part", "MeshPart", "Model", "Tool", "Weapon", "Sword", "Gun", "Ammo", "Health", "Coin"}
}

-- ESP Tracking
local espTracker = {
    playerHighlights = {},
    playerBillboards = {},
    itemHighlights = {},
    playerConnections = {},
    playerComponents = {}
}

local function getTeamList()
    local teamList = {}
    for _, team in ipairs(Teams:GetTeams()) do
        table.insert(teamList, team.Name)
    end
    return teamList
end

local function getPlayerList()
    local playerList = {}
    for _, player in ipairs(Players:GetPlayers()) do
        if player ~= LocalPlayer then
            table.insert(playerList, player.Name)
        end
    end
    return playerList
end

local function isFriend(player)
    local success, result = pcall(function()
        return LocalPlayer:IsFriendsWith(player.UserId)
    end)
    return success and result
end

local function shouldShowHitbox(player)
    if filters.forceIncludedPlayers[player.Name] then
        return true
    end
    if filters.excludedPlayers[player.Name] then
        return false
    end
    if player.Team and filters.excludedTeams[player.Team.Name] then
        return false
    end
    if filters.hideFriends and isFriend(player) then
        return false
    end
    local char = player.Character
    if char then
        if filters.hideWhenSitting then
            local humanoid = char:FindFirstChildOfClass("Humanoid")
            if humanoid and humanoid.Sit then
                return false
            end
        end
        if filters.hideForceField and char:FindFirstChildOfClass("ForceField") then
            return false
        end
    end
    return true
end

local defaultProperties = {}

local function cacheDefaults(character)
    if not character then return end
    for _, part in pairs(character:GetChildren()) do
        if part:IsA("BasePart") then
            if not defaultProperties[part] then
                defaultProperties[part] = {
                    Size = part.Size,
                    Transparency = part.Transparency,
                    CanCollide = part.CanCollide,
                    Massless = part.Massless
                }
            end
        end
    end
end

local function resetPart(part)
    if not part then return end
    local def = defaultProperties[part]
    if def then
        part.Size = def.Size
        part.Transparency = def.Transparency
        part.CanCollide = def.CanCollide
        part.Massless = def.Massless
    end
end

local function applyToPart(part, size, transparency, isNPC)
    if not part then return end
    local actualSize = isNPC and config.npcSize or size
    local actualTransparency = isNPC and config.npcTransparency or transparency
    part.Size = Vector3.new(actualSize, actualSize, actualSize)
    part.Transparency = actualTransparency
    part.CanCollide = false
    part.Massless = true
end

-- Function to apply hitbox to NPCs
local function applyNPCHitbox(model)
    if not model then return end
    
    local humanoid = model:FindFirstChildOfClass("Humanoid")
    if not humanoid or humanoid.Health <= 0 then
        -- Reset parts when dead
        for _, partsList in pairs(hitboxPartsMap) do
            for _, partName in ipairs(partsList) do
                local part = model:FindFirstChild(partName)
                if part then
                    resetPart(part)
                end
            end
        end
        return
    end

    if not config.enabled or not config.npcEnabled then
        -- Reset parts if disabled
        for _, partsList in pairs(hitboxPartsMap) do
            for _, partName in ipairs(partsList) do
                local part = model:FindFirstChild(partName)
                if part then
                    resetPart(part)
                end
            end
        end
        return
    end

    cacheDefaults(model)

    for hitboxType, enabled in pairs(hitboxToggles) do
        local partsList = hitboxPartsMap[hitboxType]
        if enabled and partsList then
            for _, partName in ipairs(partsList) do
                local part = model:FindFirstChild(partName)
                if part then
                    applyToPart(part, config.size, config.transparency, true)
                end
            end
        else
            if partsList then
                for _, partName in ipairs(partsList) do
                    local part = model:FindFirstChild(partName)
                    if part then
                        resetPart(part)
                    end
                end
            end
        end
    end
end

local function applyHitbox(player)
    if player == LocalPlayer then return end

    if not monitoredPlayers[player] then
        monitoredPlayers[player] = true

        player.CharacterAdded:Connect(function(char)
            char:WaitForChild("Humanoid", 5)
            local humanoid = char:FindFirstChildOfClass("Humanoid")
            if humanoid then
                humanoid:GetPropertyChangedSignal("Sit"):Connect(function()
                    applyHitbox(player)
                end)
            end
            char.ChildAdded:Connect(function(child)
                if child:IsA("ForceField") then
                    applyHitbox(player)
                end
            end)
            char.ChildRemoved:Connect(function(child)
                if child:IsA("ForceField") then
                    applyHitbox(player)
                end
            end)
            task.wait(0.2)
            applyHitbox(player)
        end)

        if player.Character then
            local humanoid = player.Character:FindFirstChildOfClass("Humanoid")
            if humanoid then
                humanoid:GetPropertyChangedSignal("Sit"):Connect(function()
                    applyHitbox(player)
                end)
            end
            player.Character.ChildAdded:Connect(function(child)
                if child:IsA("ForceField") then
                    applyHitbox(player)
                end
            end)
            player.Character.ChildRemoved:Connect(function(child)
                if child:IsA("ForceField") then
                    applyHitbox(player)
                end
            end)
            task.delay(0.3, function()
                applyHitbox(player)
            end)
        end
    end

    local char = player.Character
    if not char then return end

    local humanoid = char:FindFirstChildOfClass("Humanoid")
    if not humanoid or humanoid.Health <= 0 then
        for _, partsList in pairs(hitboxPartsMap) do
            for _, partName in ipairs(partsList) do
                local part = char:FindFirstChild(partName)
                if part then
                    resetPart(part)
                end
            end
        end
        return
    end

    if not config.enabled or not shouldShowHitbox(player) then
        for _, partsList in pairs(hitboxPartsMap) do
            for _, partName in ipairs(partsList) do
                local part = char:FindFirstChild(partName)
                if part then
                    resetPart(part)
                end
            end
        end
        return
    end

    cacheDefaults(char)

    for hitboxType, enabled in pairs(hitboxToggles) do
        local partsList = hitboxPartsMap[hitboxType]
        if enabled and partsList then
            for _, partName in ipairs(partsList) do
                local part = char:FindFirstChild(partName)
                if part then
                    applyToPart(part, config.size, config.transparency, false)
                end
            end
        else
            if partsList then
                for _, partName in ipairs(partsList) do
                    local part = char:FindFirstChild(partName)
                    if part then
                        resetPart(part)
                    end
                end
            end
        end
    end
end

local function updateAllHitboxes()
    for player, _ in pairs(monitoredPlayers) do
        applyHitbox(player)
    end
    for model, _ in pairs(npcTracker.activeNPCs) do
        applyNPCHitbox(model)
    end
end

-- Enhanced NPC Tracking System with Respawn Support
local function setupNPCMonitoring()
    local function isNPC(model)
        return model:IsA("Model") and 
               model:FindFirstChildOfClass("Humanoid") and
               not Players:GetPlayerFromCharacter(model)
    end

    local function trackNPC(model)
        if npcTracker.activeNPCs[model] then return end
        npcTracker.activeNPCs[model] = true
        
        local humanoid = model:FindFirstChildOfClass("Humanoid")
        if humanoid then
            -- Track health changes and death
            local healthConn = humanoid:GetPropertyChangedSignal("Health"):Connect(function()
                applyNPCHitbox(model)
            end)
            
            local diedConn = humanoid.Died:Connect(function()
                -- Immediately remove hitbox on death
                applyNPCHitbox(model)
                
                -- Wait for respawn
                local respawnConn
                respawnConn = model.AncestryChanged:Connect(function(_, parent)
                    if parent == Workspace then
                        -- Model respawned
                        task.wait(0.1)  -- Wait for model to fully load
                        applyNPCHitbox(model)
                        respawnConn:Disconnect()
                    end
                end)
            end)
            
            -- Store connections for cleanup
            npcTracker.connections[model] = {
                healthConn,
                diedConn
            }
        end
        
        -- Handle model removal
        local ancestryConn = model.AncestryChanged:Connect(function(_, parent)
            if not parent then
                if npcTracker.connections[model] then
                    for _, conn in ipairs(npcTracker.connections[model]) do
                        conn:Disconnect()
                    end
                end
                npcTracker.activeNPCs[model] = nil
                npcTracker.connections[model极] = nil
            end
        end)
        
        table.insert(npcTracker.connections[model], ancestryConn)
        
        applyNPCHitbox(model)
    end

    -- Monitor existing NPCs
    for _, model in ipairs(Workspace:GetDescendants()) do
        if isNPC(model) then
            trackNPC(model)
        end
    end

    -- Monitor for new NPCs
    Workspace.DescendantAdded:Connect(function(descendant)
        if isNPC(descendant) then
            trackNPC(descendant)
        end
    end)
end

-- ESP Functions
local function createHighlight(parent, color)
    local highlight = Instance.new("Highlight")
    highlight.FillColor = color
    highlight.OutlineColor = color
    highlight.FillTransparency = 0.5
    highlight.OutlineTransparency = 0
    highlight.Parent = parent
    return highlight
end

local function createPlayerBillboard(player, character)
    local head = character:FindFirstChild("Head")
    if not head then return nil, nil, nil end
    
    local billboard = Instance.new("BillboardGui")
    billboard.Name = "PlayerESP"
    billboard.Adornee = head
    billboard.Size = UDim2.new(0, 200, 0, 70)
    billboard.StudsOffset = Vector3.new(0, 3, 0)
    billboard.AlwaysOnTop = true
    billboard.Parent = head
    
    local nameLabel = Instance.new("TextLabel")
    nameLabel.Size = UDim2.new(1, 0, 0.3, 0)
    nameLabel.Position = UDim2.new(0, 0, 0, 0)
    nameLabel.BackgroundTransparency = 1
    nameLabel.Text = player.Name
    nameLabel.TextColor3 = espConfig.nameColor
    nameLabel.TextSize = espConfig.nameSize
    nameLabel.Font = Enum.Font.GothamBold
    nameLabel.TextStrokeTransparency = 0
    nameLabel.Visible = espConfig.showNames
    nameLabel.Parent = billboard
    
    -- Health bar container
    local healthContainer = Instance.new("Frame")
    healthContainer.Size = UDim2.new(1, 0, 0.3, 0)
    healthContainer.Position = UDim2.new(0, 0, 0.3, 0)
    healthContainer.BackgroundColor3 = Color3.new(0, 0, 0)
    healthContainer.BackgroundTransparency = 0.5
    healthContainer.BorderSizePixel = 0
    healthContainer.Visible = espConfig.showHealth
    healthContainer.Parent = billboard
    
    local healthBar = Instance.new("Frame")
    healthBar.Size = UDim2.new(1, 0, 1, 0)
    healthBar.BackgroundColor3 = espConfig.healthColor
    healthBar.BorderSizePixel = 0
    healthBar.Parent = healthContainer
    
    -- Health text display
    local healthText = Instance.new("TextLabel")
    healthText.Size = UDim2.new(1, 0, 0.3, 0)
    healthText.Position = UDim2.new(0, 0, 0.6, 0)
    healthText.BackgroundTransparency = 1
    healthText.TextColor3 = Color3.new(1, 1, 1)
    healthText.TextSize = espConfig.nameSize - 2
    healthText.Font = Enum.Font.Gotham
    healthText.Visible = espConfig.showHealth
    healthText.Parent = billboard
    
    return billboard, healthBar, healthText
end

local function updateHealthBar(player, character, healthBar, healthText)
    local humanoid = character:FindFirstChildOfClass("Humanoid")
    if humanoid and healthBar and healthText then
        local health = math.floor(humanoid.Health)
        local maxHealth = math.floor(humanoid.MaxHealth)
        local healthPercent = math.clamp(health / maxHealth, 0, 1)
        healthBar.Size = UDim2.new(healthPercent, 0, 1, 0)
        
        -- Update color based on health
        local color = Color3.new(1 - healthPercent, healthPercent, 0)
        healthBar.BackgroundColor3 = color
        
        -- Update health text
        healthText.Text = string.format("%d / %d", health, maxHealth)
    end
end

local function applyPlayerESP(player, character)
    if not character or player == LocalPlayer then return end
    
    -- Clean up previous ESP if exists
    if espTracker.playerHighlights[player] then
        espTracker.playerHighlights[player]:Destroy()
        espTracker.playerHighlights[player] = nil
    end
    
    if espTracker.playerBillboards[player] then
        espTracker.playerBillboards[player]:Destroy()
        espTracker.playerBillboards[player] = nil
    end
    
    -- Clean up connections
    if espTracker.playerConnections[player] then
        for _, conn in ipairs(espTracker.playerConnections[player]) do
            conn:Disconnect()
        end
        espTracker.playerConnections[player] = nil
    end
    
    -- Only apply if ESP is enabled
    if not espConfig.enabled then return end
    
    -- Apply new ESP
    if espConfig.highlightPlayers then
        espTracker.playerHighlights[player] = createHighlight(character, espConfig.highlightColor)
    end
    
    if espConfig.showNames or espConfig.showHealth then
        local billboard, healthBar, healthText = createPlayerBillboard(player, character)
        if billboard then
            espTracker.playerBillboards[player] = billboard
            
            -- Create health update connection
            if espConfig.showHealth then
                local humanoid = character:FindFirstChildOfClass("Humanoid")
                if humanoid then
                    -- Initial update
                    updateHealthBar(player, character, healthBar, healthText)
                    
                    -- Create connection for health changes
                    local conn = humanoid.HealthChanged:Connect(function()
                        updateHealthBar(player, character, healthBar, healthText)
                    end)
                    
                    -- Store components and connection
                    espTracker.playerComponents[player] = {
                        healthBar = healthBar,
                        healthText = healthText
                    }
                    espTracker.playerConnections[player] = {conn}
                end
            end
        end
    end
end

local function applyItemESP(item)
    if not item:IsA("BasePart") and not item:IsA("Model") then return end
    
    -- Clean up previous ESP if exists
    if espTracker.itemHighlights[item] then
        espTracker.itemHighlights[item]:Destroy()
        espTracker.itemHighlights[item] = nil
    end
    
    -- Only apply if ESP is enabled and item ESP is on
    if not espConfig.enabled or not espConfig.showItems then return end
    
    -- Apply new ESP
    for _, namePattern in ipairs(espConfig.itemNames) do
        if string.find(string.lower(item.Name), string.lower(namePattern)) then
            espTracker.itemHighlights[item] = createHighlight(item, espConfig.itemColor)
            break
        end
    end
end

local function updatePlayerESP()
    -- Update players
    for _, player in ipairs(Players:GetPlayers()) do
        if player ~= LocalPlayer and player.Character then
            applyPlayerESP(player, player.Character)
        end
    end
end

local function updateItemESP()
    -- Update items in workspace
    for _, item in ipairs(Workspace:GetDescendants()) do
        applyItemESP(item)
    end
end

local function updateAllESP()
    updatePlayerESP()
    updateItemESP()
end

local function setupESP()
    -- Player tracking
    local function setupPlayer(player)
        player.CharacterAdded:Connect(function(character)
            applyPlayerESP(player, character)
        end)
        
        if player.Character then
            applyPlayerESP(player, player.Character)
        end
    end
    
    Players.PlayerAdded:Connect(setupPlayer)
    
    for _, player in ipairs(Players:GetPlayers()) do
        if player ~= LocalPlayer then
            setupPlayer(player)
        end
    end
    
    -- Item tracking (only if enabled)
    if espConfig.showItems then
        Workspace.DescendantAdded:Connect(function(item)
            applyItemESP(item)
        end)
        
        for _, item in ipairs(Workspace:GetDescendants()) do
            applyItemESP(item)
        end
    end
end

-- MainTab Controls
MainTab:CreateToggle({
    Name = "Enable Hitbox Expander",
    CurrentValue = config.enabled,
    Flag = "HitboxToggle",
    Callback = function(Value)
        config.enabled = Value
        updateAllHitboxes()
    end,
})

MainTab:CreateToggle({
    Name = "Enable NPC Hitboxes",
    CurrentValue = config.npcEnabled,
    Flag = "NPCToggle",
    Callback = function(Value)
        config.npcEnabled = Value
        updateAllHitboxes()
    end,
})

-- Player Hitbox Settings
MainTab:CreateLabel("Player Settings")
MainTab:CreateSlider({
    Name = "Hitbox Size",
    Range = {2, 200},
    Increment = 1,
    Suffix = "Size",
    CurrentValue = config.size,
    Flag = "SizeSlider",
    Callback = function(Value)
        config.size = Value
        updateAllHitboxes()
    end,
})

MainTab:CreateSlider({
    Name = "Transparency",
    Range = {0, 1},
    Increment = 0.05,
    Suffix = "",
    CurrentValue = config.transparency,
    Flag = "TransparencySlider",
    Callback = function(Value)
        config.transparency = Value
        updateAllHitboxes()
    end,
})

-- NPC Hitbox Settings
MainTab:CreateLabel("NPC Settings")
MainTab:CreateSlider({
    Name = "NPC Hitbox Size",
    Range = {2, 200},
    Increment = 1,
    Suffix = "Size",
    CurrentValue = config.npcSize,
    Flag = "NPCSizeSlider",
    Callback = function(Value)
        config.npcSize = Value
        updateAllHitboxes()
    end,
})

MainTab:CreateSlider({
    Name = "NPC Transparency",
    Range = {0, 1},
    Increment = 0.05,
    Suffix = "",
    CurrentValue = config.npcTransparency,
    Flag = "NPCTransparencySlider",
    Callback = function(Value)
        config.npcTransparency = Value
        updateAllHitboxes()
    end,
})

local hitboxPartsOptions = {}
for partName, _ in pairs(hitboxToggles) do
    table.insert(hitboxPartsOptions, partName)
end

local defaultSelected = {}
for partName, enabled in pairs(hitboxToggles) do
    if enabled then
        table.insert(defaultSelected, partName)
    end
end

MainTab:CreateDropdown({
    Name = "Hitbox Parts",
    Options = hitboxPartsOptions,
    CurrentOption = defaultSelected,
    MultipleOptions = true,
    Flag = "HitboxPartsDropdown",
    Callback = function(selectedParts)
        for partName, _ in pairs(hitboxToggles) do
            hitboxToggles[partName] = false
        end
        for _, partName in ipairs(selectedParts) do
            hitboxToggles[partName] = true
        end
        updateAllHitboxes()
    end,
})

-- FilterTab
local playerDropdown = FilterTab:CreateDropdown({
    Name = "Exclude Players",
    Options = getPlayerList(),
    CurrentOption = "",
    MultipleOptions = true,
    Flag = "PlayerFilterDropdown",
    Callback = function(Selected)
        filters.excludedPlayers = {}
        for _, playerName in ipairs(Selected) do
            filters.excludedPlayers[playerName] = true
        end
        updateAllHitboxes()
    end,
})

local teamDropdown = FilterTab:CreateDropdown({
    Name = "Exclude Teams",
    Options = getTeamList(),
    CurrentOption = "",
    MultipleOptions = true,
    Flag = "TeamFilterDropdown",
    Callback = function(Selected)
        filters.excludedTeams = {}
        for _, teamName in ipairs(Selected) do
            filters.excludedTeams[teamName] = true
        end
        updateAllHitboxes()
    end,
})

local forceIncludeDropdown = FilterTab:CreateDropdown({
    Name = "Force Include Players",
    Options = getPlayerList(),
    CurrentOption = "",
    MultipleOptions = true,
    Flag = "ForceIncludeDropdown",
    Callback = function(Selected)
        filters.forceIncludedPlayers = {}
        for _, playerName in ipairs(Selected) do
            filters.forceIncludedPlayers[playerName] = true
        end
        updateAllHitboxes()
    end,
})

FilterTab:CreateToggle({
    Name = "Hide Hitbox When Player is Sitting",
    CurrentValue = filters.hideWhenSitting,
    Flag = "HideSittingToggle",
    Callback = function(Value)
        filters.hideWhenSitting = Value
        updateAllHitboxes()
    end
})

FilterTab:CreateToggle({
    Name = "Hide Hitbox for Friends",
    CurrentValue = filters.hideFriends,
    Flag = "HideFriendsToggle",
    Callback = function(Value)
        filters.hideFriends = Value
        updateAllHitboxes()
    end
})

FilterTab:CreateToggle({
    Name = "Hide Hitbox for Players with ForceField",
    CurrentValue = filters.hideForceField,
    Flag = "HideForceFieldToggle",
    Callback = function(Value)
        filters.hideForceField = Value
        updateAllHitboxes()
    end
})

-- ESP Tab UI
EspTab:CreateToggle({
    Name = "Enable ESP",
    CurrentValue = espConfig.enabled,
    Flag = "ESPToggle",
    Callback = function(Value)
        espConfig.enabled = Value
        updateAllESP()
    end,
})

EspTab:CreateToggle({
    Name = "Highlight Players",
    CurrentValue = espConfig.highlightPlayers,
    Flag = "HighlightToggle",
    Callback = function(Value)
        espConfig.highlightPlayers = Value
        updatePlayerESP()
    end,
})

EspTab:CreateToggle({
    Name = "Show Player Names",
    CurrentValue = espConfig.showNames,
    Flag = "NameToggle",
    Callback = function(Value)
        espConfig.showNames = Value
        updatePlayerESP()
    end,
})

EspTab:CreateToggle({
    Name = "Show Health",
    CurrentValue = espConfig.showHealth,
    Flag = "HealthToggle",
    Callback = function(Value)
        espConfig.showHealth = Value
        updatePlayerESP()
    end,
})

EspTab:CreateToggle({
    Name = "Show Items (May cause lag)",
    CurrentValue = espConfig.showItems,
    Flag = "ItemToggle",
    Callback = function(Value)
        espConfig.showItems = Value
        if Value then
            updateItemESP()
        else
            -- Clean up all item highlights
            for item, highlight in pairs(espTracker.itemHighlights) do
                highlight:Destroy()
            end
            espTracker.itemHighlights = {}
        end
    end,
})

EspTab:CreateColorPicker({
    Name = "Player Highlight Color",
    Color = espConfig.h极ightColor,
    Flag = "HighlightColor",
    Callback = function(Value)
        espConfig.highlightColor = Value
        -- Update only highlights
        for player, highlight in pairs(espTracker.playerHighlights) do
            highlight.FillColor = Value
            highlight.OutlineColor = Value
        end
    end
})

EspTab:CreateColorPicker({
    Name = "Name Color",
    Color = espConfig.nameColor,
    Flag = "NameColor",
    Callback = function(Value)
        espConfig.nameColor = Value
        -- Update only name labels
        for player, billboard in pairs(espTracker.playerBillboards) do
            local nameLabel = billboard:FindFirstChildOfClass("TextLabel")
            if nameLabel then
                nameLabel.TextColor3 = Value
            end
        end
    end
})

EspTab:CreateColorPicker({
    Name = "Health Color (Max Health)",
    Color = espConfig.healthColor,
    Flag = "HealthColor",
    Callback = function(Value)
        espConfig.healthColor = Value
        -- Health bars will use gradient, so no direct update needed
    end
})

EspTab:CreateSlider({
    Name = "Name Size",
    Range = {10, 24},
    Increment = 1,
    Suffix = "px",
    CurrentValue = espConfig.nameSize,
    Flag = "NameSizeSlider",
    Callback = function(Value)
        espConfig.nameSize = Value
        -- Update only name labels
        for player, billboard in pairs(espTracker.playerBillboards) do
            local nameLabel = billboard:FindFirstChildOfClass("TextLabel")
            if nameLabel then
                nameLabel.TextSize = Value
            end
        end
    end,
})

EspTab:CreateInput({
    Name = "Item Names (comma separated)",
    PlaceholderText = "Part, Coin, Weapon",
    RemoveTextAfterFocusLost = false,
    Callback = function(Text)
        espConfig.itemNames = {}
        for item in string.gmatch(Text, "([^,]+)") do
            table.insert(espConfig.itemNames, item:gsub("^%s*(.-)%s*$", "%1"))
        end
        if espConfig.showItems then
            updateItemESP()
        end
    end,
})

-- ScriptTab Buttons
ScriptTab:CreateButton({
    Name = "Load Shiftlock Script",
    Callback = function()
        loadstring(game:HttpGet("https://raw.githubusercontent.com/prosadaf/Example/refs/heads/main/Video"))()
    end,
})

ScriptTab:CreateButton({
    Name = "Load Infinite Yield",
    Callback = function()
        loadstring(game:HttpGet('https://raw.githubusercontent.com/EdgeIY/infiniteyield/master/source'))()
    end,
})

ScriptTab:CreateButton({
    Name = "Load Adonis Bypasser",
    Callback = function()
        loadstring(game:HttpGet("https://rawscripts.net/raw/Universal-Script-Adonis-Admin-Anti-Crash-18757"))()
    end,
})

ScriptTab:CreateButton({
    Name = "Load Abcde Bypasser",
    Callback = function()
        game:GetService("RunService").Heartbeat:Connect(function()
            task.wait(0.1)
            local char = game.Players.LocalPlayer.Character
            if char and char:FindFirstChild("abcde") then
                char.abcde:Destroy()
            end
        end)
    end,
})

ScriptTab:CreateButton({
    Name = "Load Instant Proximity",
    Callback = function()
        local ProximityPromptHoldDuration = 0
        local ChangedObjects = {}

        for _, ProximityObject in ipairs(workspace:GetDescendants()) do
            if ProximityObject:IsA("ProximityPrompt") then
                ChangedObjects[ProximityObject] = ProximityObject.HoldDuration
                ProximityObject.HoldDuration = ProximityPromptHoldDuration
            end
        end
    end,
})

-- Events
Players.PlayerAdded:Connect(function(player)
    playerDropdown:Refresh(getPlayerList(), true)
    forceIncludeDropdown:Refresh(getPlayerList(), true)
    
    -- Setup ESP for new player
    player.CharacterAdded:Connect(function(char)
        applyPlayerESP(player, char)
    end)
end)

Players.PlayerRemoving:Connect(function(player)
    if monitoredPlayers[player] then
        local char = player.Character
        if char then
            for _, partsList in pairs(hitboxPartsMap) do
                for _, partName in ipairs(partsList) do
                    local part = char:FindFirstChild(partName)
                    if part then
                        resetPart(part)
                    end
                end
            end
        end
        monitoredPlayers[player] = nil
    end
    
    -- Clean up ESP
    if espTracker.playerHighlights[player] then
        espTracker.playerHighlights[player]:Destroy()
        espTracker.playerHighlights[player] = nil
    end
    if espTracker.playerBillboards[player] then
        espTracker.playerBillboards[player]:Destroy()
        espTracker.playerBillboards[player] = nil
    end
    if espTracker.playerConnections[player] then
        for _, conn in ipairs(espTracker.playerConnections[player]) do
            conn:Disconnect()
        end
        espTracker.playerConnections[player] = nil
    end
    if espTracker.playerComponents[player] then
        espTracker.playerComponents[player] = nil
    end
    
    playerDropdown:Refresh(getPlayerList(), true)
    forceIncludeDropdown:Refresh(getPlayerList(), true)
end)

Teams.ChildAdded:Connect(function()
    teamDropdown:Refresh(getTeamList(), true)
end)

Teams.ChildRemoved:Connect(function()
    teamDropdown:Refresh(getTeamList(), true)
end)

for _, player in ipairs(Players:GetPlayers()) do
    if player ~= LocalPlayer then
        applyHitbox(player)
    end
end

Players.PlayerAdded:Connect(function(player)
    if player ~= LocalPlayer then
        applyHitbox(player)
    end
end)

-- Initialize NPC monitoring
setupNPCMonitoring()

-- Initialize ESP
setupESP()

-- Main update loop
RunService.Heartbeat:Connect(function()
    if config.enabled then
        -- Update players
        for player, _ in pairs(monitoredPlayers) do
            applyHitbox(player)
        end
        
        -- Update NPCs
        if config.npcEnabled then
            for model, _ in pairs(npcTracker.activeNPCs) do
                applyNPCHitbox(model)
            end
        end
    end
end)

task.spawn(function()
    wait(1)
    if Rayfield then
        Rayfield:ShowWindow()
        game:GetService("StarterGui"):SetCore("SendNotification", {
            Title = "Hitbox Expander",
            Text = "Press Right Shift to toggle UI",
            Duration = 5
        })
    end
end)

game:GetService("UserInputService").InputBegan:Connect(function(input, gameProcessed)
    if not gameProcessed and input.KeyCode == Enum.KeyCode.RightShift then
        if Rayfield then
            Rayfield:ToggleWindow()
        end
    end
end)