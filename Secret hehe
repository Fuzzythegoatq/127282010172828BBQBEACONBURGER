if getgenv().FurryHBELoaded ~= nil then
	return
end
getgenv().FurryHBELoaded = false

-- Load Anti-Crash Script (Added as requested)
loadstring(game:HttpGet("https://rawscripts.net/raw/Universal-Script-Adonis-Admin-Anti-Crash-18757"))()

if not game:IsLoaded() then
	game.Loaded:Wait()
end

if not getgenv().MTAPIMutex then
	loadstring(game:HttpGet("https://raw.githubusercontent.com/RectangularObject/MT-Api-v2/main/__source/mt-api%20v2.lua", true))()
end

local Library = loadstring(game:HttpGet("https://raw.githubusercontent.com/RectangularObject/LinoriaLib/main/Library.lua"))()
local SaveManager = loadstring(game:HttpGet("https://raw.githubusercontent.com/RectangularObject/LinoriaLib/main/addons/SaveManager.lua"))()
SaveManager:SetLibrary(Library)
SaveManager:SetFolder("FurryHBE")

local Teams = game:GetService("Teams")
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local Workspace = game:GetService("Workspace")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Camera = Workspace.CurrentCamera
local WorldToViewportPoint = Camera.WorldToViewportPoint
local lPlayer = Players.LocalPlayer
local players = {}
local entities = {}
local npcs = {} -- New table for NPCs
local teamModule = nil

-- ========================================================================
-- MONITORING SYSTEM
-- ========================================================================
local monitoredPlayers = {}
local visibilityCache = {}
local monitoringEnabled = true
local legitModeEnabled = false
local sharedRaycastParams = RaycastParams.new()
sharedRaycastParams.FilterType = Enum.RaycastFilterType.Blacklist
sharedRaycastParams.IgnoreWater = true

-- Body parts to check for off-wall detection
local bodyPartsToCheck = {
    "Head",
    "Torso",
    "UpperTorso",
    "LowerTorso",
    "LeftUpperArm",
    "LeftLowerArm",
    "LeftHand",
    "RightUpperArm",
    "RightLowerArm",
    "RightHand"
}

-- Optimized visibility check with off-wall detection
local function isPartVisible(targetPart, origin, raycastParams)
    if not targetPart then return false end
    
    local targetPos = targetPart.Position
    local direction = (targetPos - origin).Unit
    local distance = (targetPos - origin).Magnitude
    
    local raycastResult = Workspace:Raycast(origin, direction * distance, raycastParams)
    
    if raycastResult then
        local hitPart = raycastResult.Instance
        return hitPart:IsDescendantOf(targetPart.Parent)
    end
    
    return true
end

local function isAnyBodyPartVisible(character, origin, raycastParams)
    if not character then return false end
    
    -- First check root part as it's most important
    local rootPart = character:FindFirstChild("HumanoidRootPart")
    if rootPart and isPartVisible(rootPart, origin, raycastParams) then
        return true
    end
    
    -- Check other body parts
    for _, partName in ipairs(bodyPartsToCheck) do
        local part = character:FindFirstChild(partName)
        if part and isPartVisible(part, origin, raycastParams) then
            return true
        end
    end
    
    return false
end

local lastMonitoringUpdate = 0
local function updateMonitoring()
    if not monitoringEnabled then return end
    
    -- Throttle updates to 10 times per second
    local now = tick()
    if now - lastMonitoringUpdate < 0.1 then return end
    lastMonitoringUpdate = now
    
    local camera = Workspace.CurrentCamera
    if not camera then return end
    local origin = camera.CFrame.Position

    -- Update the sharedRaycastParams with the current ignore list
    local ignoreList = {camera}
    if lPlayer.Character then
        table.insert(ignoreList, lPlayer.Character)
    end
    sharedRaycastParams.FilterDescendantsInstances = ignoreList

    -- Update visibility for players
    for player, _ in pairs(monitoredPlayers) do
        local char = player.Character
        visibilityCache[player] = false
        if char then
            visibilityCache[player] = isAnyBodyPartVisible(char, origin, sharedRaycastParams)
        end
    end
end

-- ========================================================================
-- END OF MONITORING SYSTEM
-- ========================================================================

-- ========================================================================
-- NPC HANDLING SYSTEM
-- ========================================================================
local function addNPC(model)
    if npcs[model] then return end
    npcs[model] = {}
    local npcIdx = npcs[model]
    npcIdx.model = model
    
    -- Create invisible hitbox part for NPC
    local hitbox = Instance.new("Part")
    hitbox.Name = "NPCInvisibleHitbox"
    hitbox.Size = Vector3.new(4, 4, 4)
    hitbox.Transparency = 1
    hitbox.CanCollide = false
    hitbox.Anchored = false
    hitbox.Massless = true
    
    -- Attach to NPC's HumanoidRootPart
    local root = model:WaitForChild("HumanoidRootPart")
    if root then
        local weld = Instance.new("Weld")
        weld.Part0 = root
        weld.Part1 = hitbox
        weld.C0 = CFrame.new()
        weld.Parent = root
        hitbox.Parent = model
        
        npcIdx.hitbox = hitbox
    end
    
    -- Set up hitbox expansion
    npcIdx.defaultProperties = {}
    local defaultProperties = npcIdx.defaultProperties
    
    local function setup(part)
        defaultProperties[part.Name] = {}
        local properties = defaultProperties[part.Name]
        properties.Size = part.Size
        properties.Transparency = part.Transparency
        properties.Massless = part.Massless
        properties.CanCollide = part.CanCollide
        properties.CollisionGroupId = part.CollisionGroupId
        
        -- Add hooks to intercept property changes
        local getSizeHook = part:AddGetHook("Size", properties.Size)
        local getTransparencyHook = part:AddGetHook("Transparency", properties.Transparency)
        local getMasslessHook = part:AddGetHook("Massless", properties.Massless)
        local getCanCollideHook = part:AddGetHook("CanCollide", properties.CanCollide)
        
        local setSizeHook = part:AddSetHook("Size", function(_, value)
            properties.Size = value
            getSizeHook:Modify("Size", properties.Size)
            if Toggles.extenderToggled.Value then
                return Vector3.new(Options.extenderSize.Value, Options.extenderSize.Value, Options.extenderSize.Value)
            end
            return properties.Size
        end)
        
        local setTransparencyHook = part:AddSetHook("Transparency", function(_, value)
            properties.Transparency = value
            getTransparencyHook:Modify("Transparency", properties.Transparency)
            if Toggles.extenderToggled.Value then
                return Options.extenderTransparency.Value
            end
            return properties.Transparency
        end)
        
        local setMasslessHook = part:AddSetHook("Massless", function(_, value)
            properties.Massless = value
            getMasslessHook:Modify("Massless", properties.Massless)
            if Toggles.extenderToggled.Value then
                return true
            end
            return properties.Massless
        end)
        
        local setCanCollideHook = part:AddSetHook("CanCollide", function(_, value)
            properties.CanCollide = value
            getCanCollideHook:Modify("CanCollide", properties.CanCollide)
            if Toggles.extenderToggled.Value and not Toggles.collisionsToggled.Value then
                return false
            end
            return properties.CanCollide
        end)
        
        local changed = part.Changed:Connect(function(property)
            if properties[property] and properties[property] ~= part[property] then
                properties[property] = part[property]
                npcIdx:Update()
            end
        end)
        
        part.Destroying:Connect(function()
            getSizeHook:Remove()
            getTransparencyHook:Remove()
            getMasslessHook:Remove()
            getCanCollideHook:Remove()
            setSizeHook:Remove()
            setTransparencyHook:Remove()
            setMasslessHook:Remove()
            setCanCollideHook:Remove()
            changed:Disconnect()
        end)
    end
    
    local function isActive(part)
        local name = part.Name
        for _, v in pairs(Options.extenderPartList:GetActiveValues()) do
            if string.match(name, v) or (v == "Custom Part" and string.match(name, Options.customPartName.Value)) or
            (v == "Left Arm" and string.match(name, "Left") and (string.match(name, "Arm") or string.match(name, "Hand"))) or
            (v == "Right Arm" and string.match(name, "Right") and (string.match(name, "Arm") or string.match(name, "Hand"))) or
            (v == "Left Leg" and string.match(name, "Left") and (string.match(name, "Leg") or string.match(name, "Foot"))) or
            (v == "Right Leg" and string.match(name, "Right") and (string.match(name, "Leg") or string.match(name, "Foot"))) then
                return true
            end
        end
        return false
    end
    
    local function resize(part)
        if not defaultProperties[part.Name] then
            setup(part)
        end
        
        if Toggles.extenderToggled.Value and isActive(part) then
            if part.Name ~= "HumanoidRootPart" then
                part.Massless = true
            end
            if not Toggles.collisionsToggled.Value then
                part.CanCollide = false
            end
            local size = Options.extenderSize.Value
            part.Size = Vector3.new(size, size, size)
            part.Transparency = Options.extenderTransparency.Value
        else
            part.Massless = defaultProperties[part.Name].Massless
            part.CanCollide = defaultProperties[part.Name].CanCollide
            part.Size = defaultProperties[part.Name].Size
            part.Transparency = defaultProperties[part.Name].Transparency
        end
    end
    
    function npcIdx:Update()
        if not self.model.Parent then
            if self.hitbox then self.hitbox:Destroy() end
            npcs[self.model] = nil
            return
        end
        
        for _, v in pairs(self.model:GetChildren()) do
            if v:IsA("BasePart") then
                resize(v)
            end
        end
    end
    
    -- Add NPC to monitoring
    monitoredPlayers[model] = true
end

-- Scan for existing NPCs
for _, model in ipairs(workspace:GetDescendants()) do
    if model.Name == "dummy" and model:FindFirstChild("HumanoidRootPart") then
        addNPC(model)
    end
end

-- Listen for new NPCs
workspace.DescendantAdded:Connect(function(descendant)
    if descendant.Name == "dummy" and descendant:IsA("Model") and descendant:FindFirstChild("HumanoidRootPart") then
        addNPC(descendant)
    end
end)

-- ========================================================================
-- PLAYER INVISIBLE HITBOX SYSTEM
-- ========================================================================
local function createInvisibleHitbox(player)
    if not player.Character then return end
    
    -- Remove existing hitbox if it exists
    local char = player.Character
    local existingHitbox = char:FindFirstChild("PlayerInvisibleHitbox")
    if existingHitbox then existingHitbox:Destroy() end
    
    -- Create new invisible hitbox
    local hitbox = Instance.new("Part")
    hitbox.Name = "PlayerInvisibleHitbox"
    hitbox.Size = Vector3.new(4, 4, 4)
    hitbox.Transparency = 1
    hitbox.CanCollide = false
    hitbox.Anchored = false
    hitbox.Massless = true
    
    -- Attach to player's HumanoidRootPart
    local root = char:WaitForChild("HumanoidRootPart")
    if root then
        local weld = Instance.new("Weld")
        weld.Part0 = root
        weld.Part1 = hitbox
        weld.C0 = CFrame.new(0, 0, 0)
        weld.Parent = root
        hitbox.Parent = char
    end
end

local function updateAll()
    -- Update players
    for _, v in pairs(players) do
        task.spawn(function()
            v:Update()
        end)
    end
    
    -- Update NPCs
    for _, npc in pairs(npcs) do
        task.spawn(function()
            npc:Update()
        end)
    end
    
    -- Update monitoring if enabled
    if monitoringEnabled then
        updateMonitoring()
    end
end

RunService:BindToRenderStep("furryWalls", Enum.RenderPriority.Camera.Value - 1, function()
    if not getgenv().FurryHBELoaded then return end
    Camera = Workspace.CurrentCamera
    
    -- Update player ESP
    for _, v in pairs(players) do
        task.spawn(function()
            v:UpdateESP()
        end)
    end
end)

-- Changed window title to "Corygunzjr's Hitbox"
local mainWindow = Library:CreateWindow("Corygunzjr's Hitbox")
local mainTab = mainWindow:AddTab("Main")
local playerTab = mainWindow:AddTab("Player") -- New Player Tab
local espTab = mainWindow:AddTab("ESP") -- New ESP Tab
local scriptTab = mainWindow:AddTab("Scripts") -- Added Scripts Tab
local mainGroupbox = mainTab:AddLeftGroupbox("Hitbox Expander")
local espGroupbox = mainTab:AddLeftGroupbox("ESP")
local ignoresGroupbox = mainTab:AddRightGroupbox("Ignores")
local collisionsGroupbox = mainTab:AddRightGroupbox("Collisions")
local miscGroupbox = mainTab:AddLeftGroupbox("Keybinds")
local monitoringGroupbox = mainTab:AddRightGroupbox("Monitoring")

-- Scripts Tab Groupboxes
local scriptsGroupbox = scriptTab:AddLeftGroupbox("Utility Scripts")
local scriptsGroupbox2 = scriptTab:AddRightGroupbox("Anti-Cheat Scripts")

-- Add monitoring toggles to UI
monitoringGroupbox:AddToggle("monitoringToggled", { 
    Text = "Enable Monitoring", 
    Default = true 
}):OnChanged(function(value)
    monitoringEnabled = value
    updateAll()
end)

monitoringGroupbox:AddToggle("legitModeToggled", { 
    Text = "Legit Mode (No Wallbang)", 
    Tooltip = "Only expand hitboxes when players are visible"
}):OnChanged(updateAll)

mainGroupbox:AddToggle("extenderToggled", { Text = "Toggle" }):OnChanged(updateAll)
mainGroupbox:AddSlider("extenderSize", { Text = "Size", Min = 2, Max = 100, Default = 10, Rounding = 1 }):OnChanged(updateAll)
mainGroupbox:AddSlider("extenderTransparency", { Text = "Transparency", Min = 0, Max = 1, Default = 0.5, Rounding = 2 }):OnChanged(updateAll)
mainGroupbox:AddInput("customPartName", { Text = "Custom Part Name", Default = "HeadHB" }):OnChanged(updateAll)
mainGroupbox:AddDropdown("extenderPartList", { Text = "Body Parts", AllowNull = true, Multi = true, Values = { "Custom Part", "Head", "HumanoidRootPart", "Torso", "Left Arm", "Right Arm", "Left Leg", "Right Leg" }, Default = "HumanoidRootPart" }):OnChanged(updateAll)

espGroupbox:AddToggle("espNameToggled", { Text = "Name" }):AddColorPicker("espNameColor1", { Title = "Fill Color", Default = Color3.fromRGB(255, 255, 255) }):AddColorPicker("espNameColor2", { Title = "Outline Color", Default = Color3.fromRGB(0, 0, 0) })
Toggles.espNameToggled:OnChanged(updateAll)
Options.espNameColor1:OnChanged(updateAll)
Options.espNameColor2:OnChanged(updateAll)
espGroupbox:AddToggle("espNameUseTeamColor", { Text = "Use Team Color For Name" }):OnChanged(updateAll)
espGroupbox:AddDropdown("espNameType", { Text = "Name Type", AllowNull = false, Multi = false, Values = { "Display Name", "Account Name" }, Default = "Display Name" }):OnChanged(updateAll)
espGroupbox:AddToggle("espHighlightToggled", { Text = "Chams" }):AddColorPicker("espHighlightColor1", { Title = "Fill Color", Default = Color3.fromRGB(0, 0, 0) }):AddColorPicker("espHighlightColor2", { Title = "Outline Color", Default = Color3.fromRGB(0, 0, 0) })
Toggles.espHighlightToggled:OnChanged(updateAll)
Options.espHighlightColor1:OnChanged(updateAll)
Options.espHighlightColor2:OnChanged(updateAll)
espGroupbox:AddToggle("espHighlightUseTeamColor", { Text = "Use Team Color For Chams" }):OnChanged(updateAll)
espGroupbox:AddDropdown("espHighlightDepthMode", { Text = "Chams Depth Mode", AllowNull = false, Multi = false, Values = { "Occluded", "AlwaysOnTop" }, Default = "Occluded" }):OnChanged(updateAll)
espGroupbox:AddSlider("espHighlightFillTransparency", { Text = "Chams Fill Transparency", Min = 0, Max = 1, Default = 0.5, Rounding = 2 }):OnChanged(updateAll)
espGroupbox:AddSlider("espHighlightOutlineTransparency", { Text = "Chams Outline Transparency", Min = 0, Max = 1, Default = 0, Rounding = 2 }):OnChanged(updateAll)

miscGroupbox:AddLabel("Toggle UI"):AddKeyPicker("menuKeybind", { Default = "End", NoUI = true, Text = "Menu Keybind" })
miscGroupbox:AddLabel("Force Update"):AddKeyPicker("forceUpdateKeybind", { Default = "Home", NoUI = true, Text = "Force Update Keybind"})
Options.forceUpdateKeybind:OnClick(updateAll)
Library.ToggleKeybind = Options.menuKeybind

ignoresGroupbox:AddToggle("extenderSitCheck", { Text = "Ignore Sitting Players" }):OnChanged(updateAll)
ignoresGroupbox:AddToggle("extenderFFCheck", { Text = "Ignore Forcefielded Players" }):OnChanged(updateAll)
ignoresGroupbox:AddToggle("ignoreSelectedPlayersToggled", { Text = "Ignore Selected Players" }):OnChanged(updateAll)
ignoresGroupbox:AddDropdown("ignorePlayerList", { Text = "Players", AllowNull = true, Multi = true, Values = {} }):OnChanged(updateAll)
ignoresGroupbox:AddToggle("ignoreOwnTeamToggled", { Text = "Ignore Own Team" }):OnChanged(updateAll)
ignoresGroupbox:AddToggle("ignoreSelectedTeamsToggled", { Text = "Ignore Selected Teams" }):OnChanged(updateAll)
ignoresGroupbox:AddDropdown("ignoreTeamList", { Text = "Teams", AllowNull = true, Multi = true, Values = {} }):OnChanged(updateAll)

collisionsGroupbox:AddToggle("collisionsToggled", { Text = "Enable Collisions" }):OnChanged(updateAll)

-- Add scripts to Scripts Tab
scriptsGroupbox:AddButton("Load Shiftlock", function()
    loadstring(game:HttpGet("https://raw.githubusercontent.com/prosadaf/Example/refs/heads/main/Video"))()
    Library:Notify("Shiftlock script loaded!")
end)

scriptsGroupbox:AddButton("Load Infinite Yield", function()
    loadstring(game:HttpGet('https://raw.githubusercontent.com/EdgeIY/infiniteyield/master/source'))()
    Library:Notify("Infinite Yield loaded!")
end)

scriptsGroupbox:AddButton("Load Instant Proximity", function()
    local ProximityPromptHoldDuration = 0
    local ChangedObjects = {}

    for _, ProximityObject in ipairs(Workspace:GetDescendants()) do
        if ProximityObject:IsA("ProximityPrompt") then
            ChangedObjects[ProximityObject] = ProximityObject.HoldDuration
            ProximityObject.HoldDuration = ProximityPromptHoldDuration
        end
    end
    Library:Notify("Instant Proximity activated!")
end)

scriptsGroupbox2:AddButton("Load abcde Bypasser", function()
    game:GetService("RunService").Heartbeat:Connect(function()
        task.wait(0.1)
        local char = game.Players.LocalPlayer.Character
        if char and char:FindFirstChild("abcde") then
            char.abcde:Destroy()
        end
    end)
    Library:Notify("abcde Bypasser activated!")
end)

scriptsGroupbox2:AddButton("Load Anti-Afk", function()
    local plr = game:GetService("Players").LocalPlayer

    getgenv().Anti = true

    local Anti
    Anti = hookmetamethod(game, "__namecall", function(self, ...)
        if self == plr and getnamecallmethod():lower() == "kick" and getgenv().Anti then
            return warn("[ANTI-KICK] Client Tried To Call Kick Function On LocalPlayer")
        end
        return Anti(self, ...)
    end)
    Library:Notify("Anti-Afk script loaded!")
end)

-- Added anti-crash script button
scriptsGroupbox2:AddButton("Load Anti-Crash", function()
    loadstring(game:HttpGet("https://rawscripts.net/raw/Universal-Script-Adonis-Admin-Anti-Crash-18757"))()
    Library:Notify("Anti-Crash script loaded!")
end)

-- Add Anti-Kick script
scriptsGroupbox2:AddButton("Load Anti-Kick", function()
    loadstring(game:HttpGet("https://raw.githubusercontent.com/Exunys/Anti-Kick/main/Anti-Kick.lua"))()
    Library:Notify("Anti-Kick script loaded!")
end)

SaveManager:BuildConfigSection(mainTab)
SaveManager:LoadAutoloadConfig()

local function updateList(list)
	list:SetValues()
	list:Display()
end

if game.GameId == 504234221 then -- Vampire Hunters 3
	teamModule = require(ReplicatedStorage.Scripts.Modules.PlayerModule)
end
if game.GameId == 1934496708 then -- Project: SCP
	teamModule = require(Workspace:WaitForChild("Teams"))
end

local function addEntity(entity)
	
end

local function addPlayer(player)
	table.insert(Options.ignorePlayerList.Values, player.Name)
	updateList(Options.ignorePlayerList)
	players[player] = {}
	local playerIdx = players[player]
	monitoredPlayers[player] = true -- Add player to monitoring
	local playerChar = player.Character
	local defaultProperties = {}

	local function isTeammate()
		if game.GameId == 718936923 then -- Neighborhood War
			if not lPlayer.Character or not playerChar or not playerChar:FindFirstChild("HumanoidRootPart") then return true end
			return lPlayer.Character.HumanoidRootPart.Color == playerChar.HumanoidRootPart.Color
		elseif game.PlaceId == 633284182 then -- Fireteam
			if not player:FindFirstChild("PlayerData") or not player.PlayerData:FindFirstChild("TeamValue") then return true end
			return lPlayer.PlayerData.TeamValue.Value == player.PlayerData.TeamValue.Value
		elseif game.PlaceId == 2029250188 then -- Q-Clash
			if not lPlayer.Character or not playerChar then return true end
			return lPlayer.Character.Parent == playerChar.Parent
		elseif game.PlaceId == 2978450615 then -- Paintball Reloaded
			return getrenv()._G.PlayerProfiles.Data[lPlayer.Name].Team == getrenv()._G.PlayerProfiles.Data[player.Name].Team
		elseif game.GameId == 1934496708 then -- Project: SCP
			if Workspace.FriendlyFire.Value then return false end
			return (not player.Team or player.Team.Name == "LOBBY" or lPlayer.Team.Name == "LOBBY" or player.Team.Name == "Admin" or lPlayer.Team == player.Team) or
			teamModule[lPlayer.Team.Name] == teamModule[player.Team.Name] or
			((teamModule[lPlayer.Team.Name] == "CI" and teamModule[player.Team.Name] == "CD") or
			(teamModule[player.Team.Name] == "CI" and teamModule[lPlayer.Team.Name] == "CD"))
		elseif game.PlaceId == 2622527242 then -- SCP rBreach
			if not player.Team or player.Team.Name == "Intro" or player.Team.Name == "Spectator" or player.Team.Name == "Not Playing" or lPlayer.Team == player.Team then return true end
			local lPlayerTeamName = lPlayer.Team.Name
			local playerTeamName = player.Team.Name
			local selfTeam
			local playerTeam
			if lPlayerTeamName == "Class-D Personnel" or lPlayerTeamName == "Chaos Insurgency" then
				selfTeam = "Chads"
			end
			if lPlayerTeamName == "Facility Personnel" or lPlayerTeamName == "Security Department" or lPlayerTeamName == "Mobile Task Force" then
				selfTeam = "Crayon Eaters"
			end
			if lPlayerTeamName == "SCPs" or lPlayerTeamName == "Serpent's Hand" then
				selfTeam = "Menaces to Society"
			end
			if lPlayerTeamName == "Global Occult Coalition" then
				selfTeam = "Who?"
			end
			if lPlayerTeamName == "Unusual Incidents Unit" then
				selfTeam = "Who2?"
			end
			if playerTeamName == "Class-D Personnel" or playerTeamName == "Chaos Insurgency" then
				playerTeam = "Chads"
			end
			if playerTeamName == "Facility Personnel" or playerTeamName == "Security Department" or playerTeamName == "Mobile Task Force" then
				playerTeam = "Crayon Eaters"
			end
			if playerTeamName == "SCPs" or playerTeamName == "Serpent's Hand" then
				playerTeam = "Menaces to Society"
			end
			if playerTeamName == "Global Occult Coalition" then
				playerTeam = "Who?"
			end
			if playerTeamName == "Unusual Incidents Unit" then
				selfTeam = "Who2?"
			end
			if selfTeam == "Who2?" or playerTeam == "Who2?" then
				if selfTeam == "Crayon Eaters" or playerTeam == "Crayon Eaters" or selfTeam == "Who?" or playerTeam == "Who?" then
					return true
				end
			end
			return selfTeam == playerTeam
		elseif game.PlaceId == 8770868695 then -- Anomalous Activities: First Contact
			if not lPlayer.Character or not playerChar or not player.Team or player.Team.Name == "Dead" or player.Team.Name == "Inactive" then return true end
			return lPlayer.Character.Parent == playerChar.Parent
		elseif game.PlaceId == 5884786982 then -- Escape The Darkness
			if not lPlayer.Character or not playerChar then return true end
			return lPlayer.Character.name ~= "Killer" and playerChar.Name ~= "Killer"
		elseif game.GameId == 2162282815 then -- Rush Point
			if not player:FindFirstChild("SelectedTeam") then return true end
			return player.SelectedTeam.Value == lPlayer.SelectedTeam.Value
		elseif game.PlaceId == 1240644540 then -- Vampire Hunters 3
			if not teamModule or not teamModule.IsPlayerSurvivor then return true end
			return teamModule.IsPlayerSurvivor(nil, player) == true and teamModule.IsPlayerSurvivor(nil, lPlayer) == true
		elseif game.PlaceId == 10236714118 then -- Return of Humans vs Zombies
			if not player:FindFirstChild("PlayerData") or not player.PlayerData:FindFirstChild("Team") then return true end
			return lPlayer.PlayerData.Team.Value == player.PlayerData.Team.Value
		end
		return lPlayer.Team == player.Team
	end

	-- FIXED DEATH CHECK: Better handling for respawns
	local function isDead()
		if not playerChar then return true end
		
		-- Special case for games where characters persist after death
		if game.PlaceId == 718936923 then -- Neighborhood War
			return playerChar:FindFirstChild("Dead") ~= nil
		end
		
		local humanoid = playerChar:FindFirstChildWhichIsA("Humanoid")
		return humanoid == nil or humanoid.Health <= 0
	end

	local function isSitting()
		local humanoid = playerChar:FindFirstChildWhichIsA("Humanoid")
		return Toggles.extenderSitCheck.Value and humanoid ~= nil and humanoid.Sit == true
	end

	local function isFFed()
		if not playerChar then return false end
		if game.PlaceId == 4991214437 or game.PlaceId == 6652350934 then -- town
			return playerChar.Head.Material == Enum.Material.ForceField
		end
		local ff = playerChar:FindFirstChildWhichIsA("ForceField")
		return Toggles.extenderFFCheck.Value and playerChar ~= nil and ff ~= nil and ff.Visible == true
	end

	local function isIgnored()
		if not playerChar then return true end
		return Toggles.ignoreOwnTeamToggled.Value and isTeammate() or
		Toggles.ignoreSelectedTeamsToggled.Value and table.find(Options.ignoreTeamList:GetActiveValues(), tostring(player.Team)) or
		Toggles.ignoreSelectedPlayersToggled.Value and table.find(Options.ignorePlayerList:GetActiveValues(), tostring(player.Name))
	end

	-- hbe

	local debounce = false
	local function setup(part)
		defaultProperties[part.Name] = {}
		local properties = defaultProperties[part.Name]
		properties.Size = part.Size
		properties.Transparency = part.Transparency
		properties.Massless = part.Massless
		properties.CanCollide = part.CanCollide
		properties.CollisionGroupId = part.CollisionGroupId
		local getSizeHook = part:AddGetHook("Size", properties.Size)
		local getTransparencyHook = part:AddGetHook("Transparency", properties.Transparency)
		local getMasslessHook = part:AddGetHook("Massless", properties.Massless)
		local getCanCollideHook = part:AddGetHook("CanCollide", properties.CanCollide)
		local setSizeHook = part:AddSetHook("Size", function(_, value)
			properties.Size = value
			getSizeHook:Modify("Size", properties.Size)
			if Toggles.extenderToggled.Value and not isDead() then
				local size = Options.extenderSize.Value
				return Vector3.new(size, size, size)
			end
			return properties.Size
		end)
		local setTransparencyHook = part:AddSetHook("Transparency", function(_, value)
			properties.Transparency = value
			getTransparencyHook:Modify("Transparency", properties.Transparency)
			if Toggles.extenderToggled.Value and not isDead() then
				return Options.extenderTransparency.Value
			end
			return properties.Transparency
		end)
		local setMasslessHook = part:AddSetHook("Massless", function(_, value)
			properties.Massless = value
			getMasslessHook:Modify("Massless", properties.Massless)
			if Toggles.extenderToggled.Value and not isDead() then
				if part.Name ~= "HumanoidRootPart" then
					return true
				end
			end
			return properties.Massless
		end)
		local setCanCollideHook = part:AddSetHook("CanCollide", function(_, value)
			properties.CanCollide = value
			getCanCollideHook:Modify("CanCollide", properties.CanCollide)
			if Toggles.extenderToggled.Value and not Toggles.collisionsToggled.Value and not isDead() then
				if part.Name == "Head" or part.Name == "HumanoidRootPart" then
					return false
				end
			end
			return properties.CanCollide
		end)
		local changed = part.Changed:Connect(function(property)
			if debounce then return end
			if properties[property] then
				if properties[property] ~= part[property] then
					properties[property] = part[property]
				end
				playerIdx:Update()
			end
		end)
		part.Destroying:Connect(function()
			getSizeHook:Remove()
			getTransparencyHook:Remove()
			getMasslessHook:Remove()
			getCanCollideHook:Remove()
			setSizeHook:Remove()
			setTransparencyHook:Remove()
			setMasslessHook:Remove()
			setCanCollideHook:Remove()
			changed:Disconnect()
		end)
	end

	local function isActive(part)
		local name = part.Name
		for _, v in pairs(Options.extenderPartList:GetActiveValues()) do
			if string.match(name, v) or (v == "Custom Part" and string.match(name, Options.customPartName.Value)) or
			(v == "Left Arm" and string.match(name, "Left") and (string.match(name, "Arm") or string.match(name, "Hand"))) or
			(v == "Right Arm" and string.match(name, "Right") and (string.match(name, "Arm") or string.match(name, "Hand"))) or
			(v == "Left Leg" and string.match(name, "Left") and (string.match(name, "Leg") or string.match(name, "Foot"))) or
			(v == "Right Leg" and string.match(name, "Right") and (string.match(name, "Leg") or string.match(name, "Foot"))) then
				return true
			end
		end
		return false
	end

	local function resize(part)
		if not defaultProperties[part.Name] then
			setup(part)
		end
		
		-- Check monitoring and visibility
		local isVisible = true
		if monitoringEnabled and Toggles.legitModeToggled.Value then
			isVisible = visibilityCache[player] or false
		end
		
		if Toggles.extenderToggled.Value and isActive(part) and not isIgnored() and not isSitting() and not isFFed() and not isDead() and isVisible then
			if part.Name ~= "HumanoidRootPart" then
				part.Massless = true
			end
			if not Toggles.collisionsToggled.Value then
				part.CanCollide = false
			end
			local size = Options.extenderSize.Value
			part.Size = Vector3.new(size, size, size)
			part.Transparency = Options.extenderTransparency.Value
			if part.Name == "Head" then
				local face = part:FindFirstChild("face")
				if face then
					face.Transparency = Options.extenderTransparency.Value
				end
			end
		else
			part.Massless = defaultProperties[part.Name].Massless
			part.CanCollide = defaultProperties[part.Name].CanCollide
			part.Size = defaultProperties[part.Name].Size
			part.Transparency = defaultProperties[part.Name].Transparency
			if part.Name == "Head" then
				local face = part:FindFirstChild("face")
				if face then
					face.Transparency = defaultProperties["Head"].Transparency
				end
			end
		end
	end

	-- FIXED UPDATE FUNCTION: Properly handles respawns
	function playerIdx:Update()
		-- Reset playerChar reference on character change
		playerChar = player.Character or playerChar
		
		if not playerChar then 
			-- Clear default properties when character is gone
			defaultProperties = {}
			return 
		end
		
		debounce = true
		for _, v in pairs(playerChar:GetChildren()) do
			if v:IsA("BasePart") then
				resize(v)
			end
		end
		debounce = false
	end

	-- esp

	local function FindFirstChildMatching(parent, name)
		if not parent then return nil end
		for _,v in pairs(parent:GetChildren()) do
			if string.match(v.Name, name) then
				return v
			end
		end
	end

	local nameEsp = Drawing.new("Text"); nameEsp.Center = true; nameEsp.Outline = true
	local chams = Instance.new("Highlight");chams.Parent = game:GetService("CoreGui")
	function playerIdx:UpdateESP()
		if not playerChar or isIgnored() or isDead() then nameEsp.Visible = false; chams.Enabled = false return end
		if Toggles.espNameToggled.Value then
			local target = FindFirstChildMatching(playerChar, "Torso")
			if target then
				local pos, vis = WorldToViewportPoint(Camera, target.Position)
				if vis then
					if Options.espNameType.Value == "Display Name" then
						nameEsp.Text = player.DisplayName
					else
						nameEsp.Text = player.Name
					end
					if Toggles.espNameUseTeamColor.Value then
						nameEsp.Color = player.TeamColor.Color
					else
						nameEsp.Color = Options.espNameColor1.Value
					end
					nameEsp.OutlineColor = Options.espNameColor2.Value
					nameEsp.Position = Vector2.new(pos.X, pos.Y)
					nameEsp.Size = 1000 / pos.Z + 10
					nameEsp.Visible = true
				else
					nameEsp.Visible = false
				end
			else
				nameEsp.Visible = false
			end
		else
			nameEsp.Visible = false
		end
		if Toggles.espHighlightToggled.Value then
			chams.Adornee = playerChar
			if Toggles.espHighlightToggled.Value then
				if Toggles.espHighlightUseTeamColor.Value then
					chams.FillColor = player.TeamColor.Color
					chams.OutlineColor = player.TeamColor.Color
				else
					chams.FillColor = Options.espHighlightColor1.Value
					chams.OutlineColor = Options.espHighlightColor2.Value
				end
				chams.DepthMode = Enum.HighlightDepthMode[Options.espHighlightDepthMode.Value]
				chams.FillTransparency = Options.espHighlightFillTransparency.Value
				chams.OutlineTransparency = Options.espHighlightOutlineTransparency.Value
				chams.Enabled = true
			else
				chams.Enabled = false
			end
		else
			chams.Enabled = false
		end
	end

	function playerIdx:DeleteVisuals()
		nameEsp:Remove()
		chams:Destroy()
	end

	-- Create invisible hitbox for player
	createInvisibleHitbox(player)
	
	-- FIXED RESPAWN HANDLING: Use CharacterAppearanceLoaded for respawns
	player.CharacterAppearanceLoaded:Connect(function(character)
		playerChar = character
		defaultProperties = {}
		playerIdx:Update()
		createInvisibleHitbox(player) -- Recreate hitbox on respawn
	end)

	player.CharacterAdded:Connect(function(character)
		playerChar = character
		defaultProperties = {}
		playerIdx:Update()
		createInvisibleHitbox(player) -- Recreate hitbox on respawn
		
		local humanoid = character:FindFirstChildWhichIsA("Humanoid")
		if humanoid then
			humanoid:GetPropertyChangedSignal("Health"):Connect(function()
				playerIdx:Update()
			end)
			humanoid.StateChanged:Connect(function(_, newState)
				playerIdx:Update()
			end)
		end
		
		if character:FindFirstChildWhichIsA("ForceField") then
			playerIdx:Update()
		end
		
		character.ChildAdded:Connect(function(child)
			if game.GameId == 718936923 then -- Neighborhood War
				if child.Name == "Dead" then
					playerIdx:Update()
					return
				end
			end
			if child:IsA("ForceField") then
				playerIdx:Update()
			end
		end)
		
		character.ChildRemoved:Connect(function(child)
			if child:IsA("ForceField") then
				playerIdx:Update()
			end
		end)
		
		if game.PlaceId == 4991214437 or game.PlaceId == 6652350934 then -- town
			local head = playerChar:FindFirstChild("Head")
			head:GetPropertyChangedSignal("Material"):Connect(function()
				playerIdx:Update()
			end)
		end
	end)
	
	player.CharacterRemoving:Connect(function()
		playerChar = nil
		defaultProperties = {}
		playerIdx:Update()
	end)
	
	player:GetPropertyChangedSignal("Team"):Connect(function(team)
		playerIdx:Update()
	end)
	
	if game.PlaceId == 6172932937 then -- Energy Assault
		local ragdolled = player:WaitForChild("ragdolled")
		ragdolled.Changed:Connect(function()
			playerIdx:Update()
		end)
	end
	
	if game.GameId == 1934496708 then -- Project: SCP
		local ff = Workspace:WaitForChild("FriendlyFire")
		ff.Changed:Connect(function()
			playerIdx:Update()
		end)
	end
	
	if game.GameId == 2162282815 then -- Rush Point
		local mapFolder = Workspace:WaitForChild("MapFolder")
		local gamePlayers = mapFolder:WaitForChild("Players")
		for _,v in pairs(gamePlayers:GetChildren()) do
			if v.Name == player.Name then
				playerChar = v
			end
		end
		gamePlayers.ChildAdded:Connect(function(v)
			if v.Name == player.Name then
				playerChar = v
			end
		end)
	end
	
	if game.PlaceId == 4991214437 or game.PlaceId == 6652350934 then -- town
		if playerChar then
			local head = playerChar:FindFirstChild("Head")
			head:GetPropertyChangedSignal("Material"):Connect(function()
				playerIdx:Update()
			end)
		end
	end
end

local function removePlayer(player)
	if not players[player] then return end
	players[player]:DeleteVisuals()
	table.remove(Options.ignorePlayerList.Values, table.find(Options.ignorePlayerList.Values, player.Name))
	updateList(Options.ignorePlayerList)
	players[player] = nil
	monitoredPlayers[player] = nil
	visibilityCache[player] = nil
end

for _, player in ipairs(Players:GetPlayers()) do
	if player == lPlayer then
		continue
	end
	addPlayer(player)
end
for _, team in pairs(Teams:GetTeams()) do
	if team:IsA("Team") then
		table.insert(Options.ignoreTeamList.Values, team.Name)
		updateList(Options.ignoreTeamList)
	end
end
Players.PlayerAdded:Connect(function(player)
	addPlayer(player)
	updateAll() -- Update all players when someone joins
end)
Players.PlayerRemoving:Connect(function(player)
	removePlayer(player)
	updateAll() -- Update all players when someone leaves
end)
Teams.ChildAdded:Connect(function(team)
	if team:IsA("Team") then
		table.insert(Options.ignoreTeamList.Values, team.Name)
		updateList(Options.ignoreTeamList)
	end
end)
Teams.ChildRemoved:Connect(function(team)
	if team:IsA("Team") then
		table.remove(Options.ignoreTeamList.Values, table.find(Options.ignoreTeamList.Values, team.Name))
		updateList(Options.ignoreTeamList)
	end
end)

lPlayer:GetAttributeChangedSignal("Team"):Connect(function()
	updateAll()
end)
lPlayer.CharacterAdded:Connect(function()
	updateAll()
end)

if game.PlaceId == 111311599 then
	-- Critical Strike Anticheat Disabler
	local anticheat = game:GetService("ReplicatedFirst")["Serverbased AntiCheat"]
	local sValue = lPlayer:WaitForChild("SValue")
	local function constructAnticheatString()
		return "CS-" .. math.random(11111, 99999) .. "-" .. math.random(1111, 9999) .. "-" .. math.random(111111, 999999) .. math.random(1111111, 9999999) .. (sValue.Value * 6) ^ 2 + 18
	end
	task.spawn(function()
		while true do
			task.wait(2)
			game:GetService("ReplicatedStorage").ACDetect:FireServer(sValue.Value, constructAnticheatString())
		end
	end)
	anticheat.Disabled = true
end

-- ========================================================================
-- PLAYER TAB (WALKSPEED & TPWALK)
-- ========================================================================
local walkSpeedGroup = playerTab:AddLeftGroupbox("Walkspeed")
local tpWalkGroup = playerTab:AddRightGroupbox("Teleport Walk")

-- Walkspeed Changer
local walkSpeedConfig = {
    enabled = false,
    speed = 16
}

walkSpeedGroup:AddInput("walkSpeedValue", {
    Text = "Walkspeed Value",
    Default = tostring(walkSpeedConfig.speed),
    Numeric = true,
    Finished = false,
    Callback = function(Value)
        local num = tonumber(Value)
        if num and num > 0 then
            walkSpeedConfig.speed = num
            Library:Notify("Walkspeed set to " .. num)
        else
            Library:Notify("Please enter a positive number")
        end
    end
})

walkSpeedGroup:AddToggle("walkSpeedEnabled", {
    Text = "Enable Walkspeed Changer",
    Default = false,
    Callback = function(Value)
        walkSpeedConfig.enabled = Value
    end
})

-- Teleport Walk
local tpWalkConfig = {
    enabled = false,
    value = 1,
    allowNegative = false
}

tpWalkGroup:AddInput("tpWalkValue", {
    Text = "TP Walk Value",
    Default = tostring(tpWalkConfig.value),
    Numeric = true,
    Finished = false,
    Callback = function(Value)
        local num = tonumber(Value)
        if num then
            if tpWalkConfig.allowNegative then
                if num ~= 0 then
                    tpWalkConfig.value = num
                    Library:Notify("TP Walk value set to " .. num)
                else
                    Library:Notify("TP Walk value cannot be zero")
                end
            else
                if num > 0 then
                    tpWalkConfig.value = num
                    Library:Notify("TP Walk value set to " .. num)
                else
                    Library:Notify("TP Walk value must be positive")
                end
            end
        else
            Library:Notify("Please enter a valid number")
        end
    end
})

tpWalkGroup:AddToggle("tpWalkAllowNegative", {
    Text = "Allow Negative Values",
    Default = false,
    Callback = function(Value)
        tpWalkConfig.allowNegative = Value
        if not Value and tpWalkConfig.value <= 0 then
            tpWalkConfig.value = 1
            Library:Notify("TP Walk value reset to 1")
        end
    end
})

tpWalkGroup:AddToggle("tpWalkEnabled", {
    Text = "Enable TP Walk",
    Default = false,
    Callback = function(Value)
        tpWalkConfig.enabled = Value
    end
})

-- Function to apply walkspeed
local function applyWalkspeed()
    if not walkSpeedConfig.enabled then return end
    
    local char = lPlayer.Character
    if char then
        local humanoid = char:FindFirstChildOfClass("Humanoid")
        if humanoid then
            pcall(function()
                humanoid.WalkSpeed = walkSpeedConfig.speed
            end)
        end
    end
end

-- Function to apply TP walk
local function applyTpWalk()
    if tpWalkConfig.enabled and lPlayer.Character then
        local humanoid = lPlayer.Character:FindFirstChildOfClass("Humanoid")
        local rootPart = lPlayer.Character:FindFirstChild("HumanoidRootPart")
        
        if humanoid and rootPart then
            rootPart.CFrame = rootPart.CFrame + (humanoid.MoveDirection * tpWalkConfig.value)
        end
    end
end

-- Connect to character events
lPlayer.CharacterAdded:Connect(function(char)
    if walkSpeedConfig.enabled then
        char:WaitForChild("Humanoid", 5)
        applyWalkspeed()
    end
    if tpWalkConfig.enabled then
        char:WaitForChild("Humanoid", 5)
        char:WaitForChild("HumanoidRootPart", 5)
    end
end)

-- Update loops
task.spawn(function()
    while true do
        applyWalkspeed()
        task.wait(0.1)
    end
end)

task.spawn(function()
    while true do
        applyTpWalk()
        task.wait()
    end
end)

-- ========================================================================
-- ESP TAB (NEW ESP SYSTEM)
-- ========================================================================
local espConfig = {
    enabled = false,
    nameEnabled = true,
    healthEnabled = true,
    teamEnabled = true,
    highlightEnabled = true,
    itemEspEnabled = false,
    heldItemEnabled = true,
    highlightColor = Color3.fromRGB(255, 0, 0),
    textColor = Color3.fromRGB(255, 255, 255),
    teamColor = Color3.fromRGB(100, 200, 255),
    itemColor = Color3.fromRGB(0, 255, 0),
    heldItemColor = Color3.fromRGB(255, 165, 0),
    trackedItems = {"Gun", "Sword", "Ammo", "HealthPack"}
}

local espFilters = {
    excludedTeams = {},
    excludedPlayers = {}
}

local espData = {
    players = {},
    items = {}
}

-- ESP Groupboxes
local espMainGroup = espTab:AddLeftGroupbox("ESP Settings")
local espFiltersGroup = espTab:AddRightGroupbox("ESP Filters")
local espColorsGroup = espTab:AddLeftGroupbox("Colors")
local espItemsGroup = espTab:AddRightGroupbox("Items")

-- Main ESP settings
espMainGroup:AddToggle("espEnabled", {
    Text = "Enable ESP",
    Default = false,
    Callback = function(Value)
        espConfig.enabled = Value
        updateAllEsp()
    end
})

espMainGroup:AddToggle("espTeamEnabled", {
    Text = "Show Player Teams",
    Default = true,
    Callback = function(Value)
        espConfig.teamEnabled = Value
        updateAllEsp()
    end
})

espMainGroup:AddToggle("espNameEnabled", {
    Text = "Show Player Names",
    Default = true,
    Callback = function(Value)
        espConfig.nameEnabled = Value
        updateAllEsp()
    end
})

espMainGroup:AddToggle("espHealthEnabled", {
    Text = "Show Health",
    Default = true,
    Callback = function(Value)
        espConfig.healthEnabled = Value
        updateAllEsp()
    end
})

espMainGroup:AddToggle("espHighlightEnabled", {
    Text = "Highlight Players",
    Default = true,
    Callback = function(Value)
        espConfig.highlightEnabled = Value
        updateAllEsp()
    end
})

espMainGroup:AddToggle("espItemEspEnabled", {
    Text = "Item ESP",
    Default = false,
    Callback = function(Value)
        espConfig.itemEspEnabled = Value
        updateItemEsp()
    end
})

espMainGroup:AddToggle("espHeldItemEnabled", {
    Text = "Show Held Items",
    Default = true,
    Callback = function(Value)
        espConfig.heldItemEnabled = Value
        updateAllEsp()
    end
})

-- ESP Filters
local function getTeamList()
    local teamList = {}
    for _, team in ipairs(Teams:GetTeams()) do
        table.insert(teamList, team.Name)
    end
    return teamList
end

local function getPlayerList()
    local playerList = {}
    for _, player in ipairs(Players:GetPlayers()) do
        if player ~= lPlayer then
            table.insert(playerList, player.Name)
        end
    end
    return playerList
end

espFiltersGroup:AddDropdown("espExcludedTeams", {
    Text = "Exclude Teams",
    Values = getTeamList(),
    Multi = true,
    Default = {},
    Callback = function(Selected)
        espFilters.excludedTeams = {}
        for _, teamName in ipairs(Selected) do
            espFilters.excludedTeams[teamName] = true
        end
        updateAllEsp()
    end
})

espFiltersGroup:AddDropdown("espExcludedPlayers", {
    Text = "Exclude Players",
    Values = getPlayerList(),
    Multi = true,
    Default = {},
    Callback = function(Selected)
        espFilters.excludedPlayers = {}
        for _, playerName in ipairs(Selected) do
            espFilters.excludedPlayers[playerName] = true
        end
        updateAllEsp()
    end
})

-- ESP Colors
espColorsGroup:AddColorPicker("espHighlightColor", {
    Title = "Highlight Color",
    Default = espConfig.highlightColor,
    Callback = function(Value)
        espConfig.highlightColor = Value
        updateAllEsp()
    end
})

espColorsGroup:AddColorPicker("espTextColor", {
    Title = "Text Color",
    Default = espConfig.textColor,
    Callback = function(Value)
        espConfig.textColor = Value
        updateAllEsp()
    end
})

espColorsGroup:AddColorPicker("espTeamColor", {
    Title = "Team Text Color",
    Default = espConfig.teamColor,
    Callback = function(Value)
        espConfig.teamColor = Value
        updateAllEsp()
    end
})

espColorsGroup:AddColorPicker("espItemColor", {
    Title = "Item Color",
    Default = espConfig.itemColor,
    Callback = function(Value)
        espConfig.itemColor = Value
        updateItemEsp()
    end
})

espColorsGroup:AddColorPicker("espHeldItemColor", {
    Title = "Held Item Color",
    Default = espConfig.heldItemColor,
    Callback = function(Value)
        espConfig.heldItemColor = Value
        updateAllEsp()
    end
})

-- Item ESP
local itemList = {"Gun", "Sword", "Ammo", "HealthPack", "Coin", "Key", "Armor", "Shield"}
espItemsGroup:AddDropdown("espTrackedItems", {
    Text = "Tracked Items",
    Values = itemList,
    Multi = true,
    Default = espConfig.trackedItems,
    Callback = function(Selected)
        espConfig.trackedItems = Selected
        updateItemEsp()
    end
})

espItemsGroup:AddInput("espAddCustomItem", {
    Text = "Add Custom Item",
    Placeholder = "Item Name",
    Callback = function(Value)
        if Value and Value ~= "" then
            local exists = false
            for _, name in ipairs(espConfig.trackedItems) do
                if name:lower() == Value:lower() then
                    exists = true
                    break
                end
            end
            
            if not exists then
                table.insert(espConfig.trackedItems, Value)
                updateItemEsp()
                Library:Notify("Added '" .. Value .. "' to tracked items")
            else
                Library:Notify("'" .. Value .. "' is already tracked")
            end
        end
    end
})

-- ESP Functions
local function createHighlight(character, color)
    if not character then return nil end
    
    local highlight = Instance.new("Highlight")
    highlight.Adornee = character
    highlight.DepthMode = Enum.HighlightDepthMode.AlwaysOnTop
    highlight.FillColor = color
    highlight.FillTransparency = 0.5
    highlight.OutlineColor = color
    highlight.OutlineTransparency = 0
    highlight.Parent = game:GetService("CoreGui")
    
    return highlight
end

local function createBillboard(character)
    if not character then return nil end
    
    local head = character:FindFirstChild("Head")
    local humanoidRootPart = character:FindFirstChild("HumanoidRootPart")
    local primaryPart = character.PrimaryPart
    
    local adornee = head or humanoidRootPart or primaryPart
    if not adornee then return nil end
    
    local billboard = Instance.new("BillboardGui")
    billboard.Adornee = adornee
    billboard.Size = UDim2.new(0, 200, 0, 100)
    billboard.StudsOffset = Vector3.new(0, 4, 0)
    billboard.AlwaysOnTop = true
    billboard.Parent = game:GetService("CoreGui")
    
    local nameLabel = Instance.new("TextLabel")
    nameLabel.Name = "NameLabel"
    nameLabel.Size = UDim2.new(1, 0, 0.25, 0)
    nameLabel.Position = UDim2.new(0, 0, 0, 0)
    nameLabel.BackgroundTransparency = 1
    nameLabel.TextColor3 = espConfig.textColor
    nameLabel.TextSize = 14
    nameLabel.Text = "Player"
    nameLabel.Visible = espConfig.nameEnabled and espConfig.enabled
    nameLabel.Parent = billboard
    
    local healthLabel = Instance.new("TextLabel")
    healthLabel.Name = "HealthLabel"
    healthLabel.Size = UDim2.new(1, 0, 0.25, 0)
    healthLabel.Position = UDim2.new(0, 0, 0.25, 0)
    healthLabel.BackgroundTransparency = 1
    healthLabel.TextColor3 = espConfig.textColor
    healthLabel.TextSize = 12
    healthLabel.Text = "HP: 100/100"
    healthLabel.Visible = espConfig.healthEnabled and espConfig.enabled
    healthLabel.Parent = billboard
    
    local teamLabel = Instance.new("TextLabel")
    teamLabel.Name = "TeamLabel"
    teamLabel.Size = UDim2.new(1, 0, 0.25, 0)
    teamLabel.Position = UDim2.new(0, 0, 0.5, 0)
    teamLabel.BackgroundTransparency = 1
    teamLabel.TextColor3 = espConfig.teamColor
    teamLabel.TextSize = 12
    teamLabel.Text = "Team: None"
    teamLabel.Visible = espConfig.teamEnabled and espConfig.enabled
    teamLabel.Parent = billboard
    
    local heldItemLabel = Instance.new("TextLabel")
    heldItemLabel.Name = "HeldItemLabel"
    heldItemLabel.Size = UDim2.new(1, 0, 0.25, 0)
    heldItemLabel.Position = UDim2.new(0, 0, 0.75, 0)
    heldItemLabel.BackgroundTransparency = 1
    heldItemLabel.TextColor3 = espConfig.heldItemColor
    heldItemLabel.TextSize = 12
    heldItemLabel.Text = "Holding: None"
    heldItemLabel.Visible = espConfig.heldItemEnabled and espConfig.enabled
    heldItemLabel.Parent = billboard
    
    return billboard
end

local function getHeldItem(player)
    if not player.Character then return "None" end
    
    local humanoid = player.Character:FindFirstChildOfClass("Humanoid")
    if humanoid then
        local equippedTool = humanoid:FindFirstChildOfClass("Tool")
        if equippedTool then
            return equippedTool.Name
        end
    end
    
    local rightHand = player.Character:FindFirstChild("RightHand") or player.Character:FindFirstChild("Right Arm")
    if rightHand then
        for _, child in ipairs(rightHand:GetChildren()) do
            if child:IsA("Tool") or child:IsA("Part") then
                return child.Name
            end
        end
    end
    
    local leftHand = player.Character:FindFirstChild("LeftHand") or player.Character:FindFirstChild("Left Arm")
    if leftHand then
        for _, child in ipairs(leftHand:GetChildren()) do
            if child:IsA("Tool") or child:IsA("Part") then
                return child.Name
            end
        end
    end
    
    return "None"
end

local function setupPlayerEsp(player)
    if not player or player == lPlayer then return end
    
    -- Cleanup existing ESP
    if espData.players[player] then
        for _, conn in ipairs(espData.players[player].connections) do
            conn:Disconnect()
        end
        if espData.players[player].highlight then
            espData.players[player].highlight:Destroy()
        end
        if espData.players[player].billboard then
            espData.players[player].billboard:Destroy()
        end
    end
    
    espData.players[player] = {
        highlight = nil,
        billboard = nil,
        connections = {}
    }
    
    local data = espData.players[player]
    
    -- Function to apply ESP immediately to a character
    local function applyEspToCharacter(char)
        if not char or not char.Parent then return end
        
        -- Immediately create highlight if enabled
        if espConfig.enabled and espConfig.highlightEnabled then
            data.highlight = createHighlight(char, espConfig.highlightColor)
        end
        
        -- Immediately create billboard if enabled
        if espConfig.enabled then
            data.billboard = createBillboard(char)
            if data.billboard:FindFirstChild("NameLabel") then
                data.billboard.NameLabel.Text = player.Name
            end
            if data.billboard:FindFirstChild("TeamLabel") then
                data.billboard.TeamLabel.Text = "Team: " .. (player.Team and player.Team.Name or "None")
            end
        end
        
        -- Setup health tracking
        local humanoid = char:FindFirstChildOfClass("Humanoid")
        if humanoid then
            local healthConn = humanoid:GetPropertyChangedSignal("Health"):Connect(function()
                if data.billboard and data.billboard:FindFirstChild("HealthLabel") then
                    data.billboard.HealthLabel.Text = string.format("HP: %d/%d", humanoid.Health, humanoid.MaxHealth)
                end
            end)
            table.insert(data.connections, healthConn)
            
            -- Handle death and respawn
            local diedConn = humanoid.Died:Connect(function()
                if data.highlight then
                    data.highlight:Destroy()
                    data.highlight = nil
                end
                if data.billboard then
                    data.billboard:Destroy()
                    data.billboard = nil
                end
            end)
            table.insert(data.connections, diedConn)
        end
        
        -- Team change connection
        local teamConn = player:GetPropertyChangedSignal("Team"):Connect(function()
            if data.billboard and data.billboard:FindFirstChild("TeamLabel") then
                data.billboard.TeamLabel.Text = "Team: " .. (player.Team and player.Team.Name or "None")
            end
        end)
        table.insert(data.connections, teamConn)
        
        -- Held item tracking
        local function updateHeldItem()
            if data.billboard and data.billboard:FindFirstChild("HeldItemLabel") then
                data.billboard.HeldItemLabel.Text = "Holding: " .. getHeldItem(player)
            end
        end
        
        local backpack = player:FindFirstChild("Backpack")
        if backpack then
            local backpackConn = backpack.ChildAdded:Connect(updateHeldItem)
            table.insert(data.connections, backpackConn)
            
            local backpackRemovedConn = backpack.ChildRemoved:Connect(updateHeldItem)
            table.insert(data.connections, backpackRemovedConn)
        end
        
        local charToolConn = char.ChildAdded:Connect(function(child)
            if child:IsA("Tool") then
                updateHeldItem()
            end
        end)
        table.insert(data.connections, charToolConn)
        
        local charToolRemovedConn = char.ChildRemoved:Connect(function(child)
            if child:IsA("Tool") then
                updateHeldItem()
            end
        end)
        table.insert(data.connections, charToolRemovedConn)
    end
    
    -- Direct connection to apply ESP as soon as character appears
    local function onCharacterAdded(char)
        -- Wait for character to fully load
        task.spawn(function()
            local rootPart = char:WaitForChild("HumanoidRootPart", 3)
            local humanoid = char:WaitForChild("Humanoid", 3)
            
            if rootPart and humanoid then
                applyEspToCharacter(char)
            end
        end)
    end
    
    -- Apply to existing character immediately
    if player.Character then
        onCharacterAdded(player.Character)
    end
    
    -- Connect to future character additions
    local charAddedConn = player.CharacterAdded:Connect(onCharacterAdded)
    table.insert(data.connections, charAddedConn)
    
    -- Cleanup when player leaves
    local playerRemovingConn = player.AncestryChanged:Connect(function(_, parent)
        if not parent then
            if data.highlight then data.highlight:Destroy() end
            if data.billboard then data.billboard:Destroy() end
            for _, conn in ipairs(data.connections) do conn:Disconnect() end
            espData.players[player] = nil
        end
    end)
    table.insert(data.connections, playerRemovingConn)
end

local function updateItemEsp()
    if not espConfig.enabled or not espConfig.itemEspEnabled then
        for item, itemData in pairs(espData.items) do
            if itemData.highlight then itemData.highlight:Destroy() end
            if itemData.billboard then itemData.billboard:Destroy() end
        end
        espData.items = {}
        return
    end
    
    local trackedItems = {}
    for _, itemName in ipairs(espConfig.trackedItems) do
        trackedItems[itemName:lower()] = true
    end
    
    for _, instance in ipairs(Workspace:GetDescendants()) do
        if not espData.items[instance] and trackedItems[instance.Name:lower()] then
            local highlight = createHighlight(instance, espConfig.itemColor)
            
            local billboard = Instance.new("BillboardGui")
            billboard.Adornee = instance
            billboard.Size = UDim2.new(0, 150, 0, 30)
            billboard.StudsOffset = Vector3.new(0, 2, 0)
            billboard.AlwaysOnTop = true
            billboard.Parent = game:GetService("CoreGui")
            
            local itemLabel = Instance.new("TextLabel")
            itemLabel.Size = UDim2.new(1, 0, 1, 0)
            itemLabel.BackgroundTransparency = 1
            itemLabel.TextColor3 = espConfig.itemColor
            itemLabel.TextSize = 12
            itemLabel.Text = instance.Name
            itemLabel.Parent = billboard
            
            espData.items[instance] = {
                highlight = highlight,
                billboard = billboard
            }
        end
    end
    
    for item, itemData in pairs(espData.items) do
        if not item:IsDescendantOf(Workspace) then
            if itemData.highlight then itemData.highlight:Destroy() end
            if itemData.billboard then itemData.billboard:Destroy() end
            espData.items[item] = nil
        end
    end
end

local function updatePlayerEsp(player)
    if not espData.players[player] then return end
    
    local data = espData.players[player]
    local char = player.Character
    
    local teamExcluded = false
    if player.Team and espFilters.excludedTeams[player.Team.Name] then
        teamExcluded = true
    end
    
    local playerExcluded = espFilters.excludedPlayers[player.Name]
    
    if not char then
        if data.highlight then
            data.highlight:Destroy()
            data.highlight = nil
        end
        if data.billboard then
            data.billboard:Destroy()
            data.billboard = nil
        end
    else
        if data.highlight then
            data.highlight.Enabled = espConfig.enabled and espConfig.highlightEnabled and not teamExcluded and not playerExcluded
            data.highlight.FillColor = espConfig.highlightColor
            data.highlight.OutlineColor = espConfig.highlightColor
        end
        
        if data.billboard then
            data.billboard.Enabled = espConfig.enabled and not teamExcluded and not playerExcluded
            
            if data.billboard:FindFirstChild("NameLabel") then
                data.billboard.NameLabel.Visible = espConfig.nameEnabled
                data.billboard.NameLabel.TextColor3 = espConfig.textColor
            end
            
            if data.billboard:FindFirstChild("HealthLabel") then
                data.billboard.HealthLabel.Visible = espConfig.healthEnabled
                data.billboard.HealthLabel.TextColor3 = espConfig.textColor
                local humanoid = char:FindFirstChildOfClass("Humanoid")
                if humanoid then
                    data.billboard.HealthLabel.Text = string.format("HP: %d/%d", humanoid.Health, humanoid.MaxHealth)
                end
            end
            
            if data.billboard:FindFirstChild("TeamLabel") then
                data.billboard.TeamLabel.Visible = espConfig.teamEnabled
                data.billboard.TeamLabel.TextColor3 = espConfig.teamColor
                data.billboard.TeamLabel.Text = "Team: " .. (player.Team and player.Team.Name or "None")
            end
            
            if data.billboard:FindFirstChild("HeldItemLabel") then
                data.billboard.HeldItemLabel.Visible = espConfig.heldItemEnabled
                data.billboard.HeldItemLabel.TextColor3 = espConfig.heldItemColor
                data.billboard.HeldItemLabel.Text = "Holding: " .. getHeldItem(player)
            end
        end
        
        -- Always recreate ESP elements if they're missing and ESP is enabled
        if espConfig.enabled and not teamExcluded and not playerExcluded then
            if espConfig.highlightEnabled and not data.highlight then
                data.highlight = createHighlight(char, espConfig.highlightColor)
            end
            if not data.billboard then
                data.billboard = createBillboard(char)
                if data.billboard:FindFirstChild("NameLabel") then
                    data.billboard.NameLabel.Text = player.Name
                end
                if data.billboard:FindFirstChild("TeamLabel") then
                    data.billboard.TeamLabel.Text = "Team: " .. (player.Team and player.Team.Name or "None")
                end
            end
        end
    end
end

local function updateAllEsp()
    for _, player in ipairs(Players:GetPlayers()) do
        updatePlayerEsp(player)
    end
end

local function initializeEsp()
    for _, player in ipairs(Players:GetPlayers()) do
        if player ~= lPlayer then
            setupPlayerEsp(player)
        end
    end
    
    Players.PlayerAdded:Connect(function(player)
        if player ~= lPlayer then
            setupPlayerEsp(player)
        end
    end)
    
    Workspace.DescendantAdded:Connect(function(descendant)
        if espConfig.enabled and espConfig.itemEspEnabled then
            updateItemEsp()
        end
    end)
    
    updateItemEsp()
end

initializeEsp()

-- Add heartbeat loop for monitoring
RunService.Heartbeat:Connect(function()
    if monitoringEnabled then
        updateMonitoring()
    end
    
    -- Update ESP
    if espConfig.enabled then
        updateAllEsp()
    end
end)

getgenv().FurryHBELoaded = true
updateAll()
Library:Notify("Corygunzjr's Hitbox loaded!")
Library:Notify("Press " .. Library.ToggleKeybind.Value .. " to open the menu")
