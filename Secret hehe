getgenv().SecureMode = true      
-- Load Rayfield UI
local Rayfield = loadstring(game:HttpGet("https://sirius.menu/rayfield"))()

-- Initial notification
game:GetService("StarterGui"):SetCore("SendNotification", {
    Title = "Universal Hitbox Expander",
    Text = "Made By Corygunzjr",
    Duration = 5
})

-- UI Setup
local Window = Rayfield:CreateWindow({
    Name = "Universal Hitbox Expander",
    LoadingTitle = "Loading HBE...",
    LoadingSubtitle = "With Team/Player Selection & Multi-Hitbox",
    ConfigurationSaving = {
        Enabled = true,
        FolderName = "RayfieldHBE",
        FileName = "HBEConfig"
    },
    Discord = { Enabled = false },
    KeySystem = false
})

-- Create tabs
local MainTab = Window:CreateTab("Hitbox Expander", 4483362458)
local FilterTab = Window:CreateTab("Filters", 4483362458)
local ScriptTab = Window:CreateTab("Script", 4483362458)
local EspTab = Window:CreateTab("ESP", 4483362458)
local ThemesTab = Window:CreateTab("Themes", 4483362458) -- New Themes tab
local CreditsTab = Window:CreateTab("Credits", 4483362458) -- Credits tab

-- ====================== THEMES TAB CONTENT ======================
ThemesTab:CreateDropdown({
   Name = "Current Theme",
   Options = {"Default", "AmberGlow", "Amethyst", "Bloom", "DarkBlue", "Green", "Light", "Ocean", "Serenity"},
   CurrentOption = {"Default"},
   MultipleOptions = false,
   Flag = "CurrentTheme",
   Callback = function(Options)
        Window.ModifyTheme(Options[1])
   end
})

ThemesTab:CreateParagraph({
    Title = "Theme Selection",
    Content = "Change the visual appearance of the UI. Select a theme from the dropdown above."
})

ThemesTab:CreateSection("Theme Preview")
ThemesTab:CreateLabel("Default: Clean dark interface")
ThemesTab:CreateLabel("AmberGlow: Warm orange tones")
ThemesTab:CreateLabel("Amethyst: Purple theme")
ThemesTab:CreateLabel("Bloom: Bright theme with light colors")
ThemesTab:CreateLabel("DarkBlue: Deep blue interface")
ThemesTab:CreateLabel("Green: Nature-inspired theme")
ThemesTab:CreateLabel("Light: Bright minimal interface")
ThemesTab:CreateLabel("Ocean: Blue sea colors")
ThemesTab:CreateLabel("Serenity: Calm purple-blue mix")
-- ====================== END THEMES TAB ======================

-- Services
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local LocalPlayer = Players.LocalPlayer
local Workspace = game:GetService("Workspace")
local Teams = game:GetService("Teams")

-- Configuration system
local config = {
    size = 5,
    transparency = 0.5,
    enabled = false,
    npcEnabled = false,
    npcSize = 5,
    npcTransparency = 0.5,
    collideEnabled = false,
    npcCollideEnabled = false,
    bypassDetection = false,
    bypassMethods = {"Size Variation"},
    invisibleHitbox = false,
    legitMode = false,
    offWallThreshold = 0.3,  -- Off-wall detection threshold
    hideTeammates = false,   -- New team filtering option
    attachToRoot = false,    -- New: Attach to root part
    rootSize = 5,            -- New: Size for root hitbox
    hideNPCHitboxes = false, -- New: Hide all NPC hitboxes
    hideTeammateNPCs = false -- New: Hide teammate NPCs
}

-- NEW: Visibility tracking
local visibilityCache = {}

-- Bypass variables
local bypassRandomSize = 0
local bypassRandomTransparency = 0
local bypassRandomOffset = Vector3.new(0, 0, 0)
local lastBypassUpdate = 0
local bypassMethodsList = {"Size Variation", "Transparency Variation", "Position Offset", "Dynamic Scaling"}

-- Filter system
local filters = {
    excludedPlayers = {},
    excludedTeams = {},
    forceIncludedPlayers = {},
    hideWhenSitting = false,
    hideFriends = false,
    hideForceField = false
}

-- Hitbox toggle config
local hitboxToggles = {
    Head = true,
    ["Left Arm"] = false,
    ["Right Arm"] = false,
    ["Left Leg"] = false,
    ["Right Leg"] = false,
    Torso = false,
}

-- Player monitoring
local monitoredPlayers = {}
-- NPC monitoring system
local npcTracker = {
    activeNPCs = {},
    connections = {}
}

-- Mapping of hitbox type to body parts
local hitboxPartsMap = {
    Head = {"Head"},
    ["Left Arm"] = {"LeftLowerArm", "LeftUpperArm"},
    ["Right Arm"] = {"RightLowerArm", "RightUpperArm"},
    ["Left Leg"] = {"LeftLowerLeg", "LeftUpperLeg"},
    ["Right Leg"] = {"RightLowerLeg", "RightUpperLeg"},
    Torso = {"Torso", "UpperTorso", "LowerTorso"}
}

-- ESP Configuration
local espConfig = {
    enabled = false,
    nameEnabled = true,
    healthEnabled = true,
    teamEnabled = true,
    highlightEnabled = true,
    itemEspEnabled = false,
    heldItemEnabled = true,
    highlightColor = Color3.fromRGB(255, 0, 0),
    textColor = Color3.fromRGB(255, 255, 255),
    teamColor = Color3.fromRGB(100, 200, 255),
    itemColor = Color3.fromRGB(0, 255, 0),
    heldItemColor = Color3.fromRGB(255, 165, 0),
    trackedItems = {"Gun", "Sword", "Ammo", "HealthPack"}
}

-- ESP filters
local espFilters = {
    excludedTeams = {},
    excludedPlayers = {}
}

-- ESP Data Storage
local espData = {
    players = {},
    items = {}
}

-- ========================================================================
-- TEAM-BASED FILTERING SYSTEM
-- ========================================================================

local function isTeammate(player)
    if player == LocalPlayer then return true end
    
    local gameId = game.GameId
    local placeId = game.PlaceId

    -- Neighborhood War
    if gameId == 718936923 then 
        local lChar = LocalPlayer.Character
        local pChar = player.Character
        if not lChar or not pChar then return true end
        local lRoot = lChar:FindFirstChild("HumanoidRootPart")
        local pRoot = pChar:FindFirstChild("HumanoidRootPart")
        if not lRoot or not pRoot then return true end
        return lRoot.Color == pRoot.Color

    -- Fireteam
    elseif placeId == 633284182 then 
        if not player:FindFirstChild("PlayerData") or not LocalPlayer:FindFirstChild("PlayerData") then return true end
        local pTeam = player.PlayerData:FindFirstChild("TeamValue")
        local lTeam = LocalPlayer.PlayerData:FindFirstChild("TeamValue")
        if not pTeam or not lTeam then return true end
        return lTeam.Value == pTeam.Value

    -- Q-Clash
    elseif placeId == 2029250188 then 
        local lChar = LocalPlayer.Character
        local pChar = player.Character
        if not lChar or not pChar then return true end
        return lChar.Parent == pChar.Parent

    -- Paintball Reloaded
    elseif placeId == 2978450615 then 
        local renv = getrenv()
        if not renv or not renv.G then return true end
        local profiles = renv.G.PlayerProfiles
        if not profiles or not profiles.Data then return true end
        return profiles.Data[LocalPlayer.Name].Team == profiles.Data[player.Name].Team

    -- Project: SCP
    elseif gameId == 1934496708 then 
        if Workspace:FindFirstChild("FriendlyFire") and Workspace.FriendlyFire.Value then 
            return false 
        end
        if not player.Team or not LocalPlayer.Team then return true end
        return player.Team == LocalPlayer.Team

    -- SCP rBreach
    elseif placeId == 2622527242 then 
        -- Add your custom team check logic here
        return player.Team == LocalPlayer.Team

    -- Default team check
    else
        return player.Team == LocalPlayer.Team
    end
end

-- ========================================================================
-- ENHANCED LEGIT HITBOX WITH OFF-WALL DETECTION
-- ========================================================================

-- Create shared RaycastParams object
local sharedRaycastParams = RaycastParams.new()
sharedRaycastParams.FilterType = Enum.RaycastFilterType.Blacklist
sharedRaycastParams.IgnoreWater = true

-- Body parts to check for off-wall detection (excluding legs)
local bodyPartsToCheck = {
    "Head",
    "Torso",
    "UpperTorso",
    "LowerTorso",
    "LeftUpperArm",
    "LeftLowerArm",
    "LeftHand",
    "RightUpperArm",
    "RightLowerArm",
    "RightHand"
}

-- Optimized visibility check with off-wall detection (no distance limit)
local function isPartVisible(targetPart, origin, raycastParams)
    if not targetPart then return false end
    
    local targetPos = targetPart.Position
    local direction = (targetPos - origin).Unit
    local distance = (targetPos - origin).Magnitude
    
    local raycastResult = Workspace:Raycast(origin, direction * distance, raycastParams)
    
    if raycastResult then
        local hitPart = raycastResult.Instance
        -- Check if we hit the target or something else
        return hitPart:IsDescendantOf(targetPart.Parent)
    end
    
    return true
end

-- New: Check if any body part (except legs) is visible
local function isAnyBodyPartVisible(character, origin, raycastParams)
    if not character then return false end
    
    -- First check root part as it's most important
    local rootPart = character:FindFirstChild("HumanoidRootPart")
    if rootPart and isPartVisible(rootPart, origin, raycastParams) then
        return true
    end
    
    -- Check other body parts
    for _, partName in ipairs(bodyPartsToCheck) do
        local part = character:FindFirstChild(partName)
        if part and isPartVisible(part, origin, raycastParams) then
            return true
        end
    end
    
    return false
end

-- Bypass hitbox detection techniques
local function applyBypassTechniques(part, isNPC)
    if not config.bypassDetection or not part then return end
    
    local currentTime = tick()
    if currentTime - lastBypassUpdate > 1.5 then
        bypassRandomSize = math.random(80, 120) / 100
        bypassRandomTransparency = math.random(-20, 20) / 100
        bypassRandomOffset = Vector3.new(math.random(-5, 5)/10, math.random(-5, 5)/10, math.random(-5, 5)/10)
        lastBypassUpdate = currentTime
    end
    
    local actualSize = isNPC and config.npcSize or config.size
    local actualTransparency = isNPC and config.npcTransparency or config.transparency
    
    for _, method in ipairs(config.bypassMethods) do
        if method == "Size Variation" then
            part.Size = Vector3.new(actualSize * bypassRandomSize, actualSize * bypassRandomSize, actualSize * bypassRandomSize)
        elseif method == "Transparency Variation" then
            part.Transparency = math.clamp(actualTransparency + bypassRandomTransparency, 0, 1)
        elseif method == "Position Offset" then
            part.CFrame = part.CFrame + bypassRandomOffset
        elseif method == "Dynamic Scaling" then
            local scale = 0.8 + math.sin(tick()) * 0.2
            part.Size = Vector3.new(actualSize * scale, actualSize * scale, actualSize * scale)
        end
    end
end

-- FIXED: Check if NPC is on local player's team (won't mistake players for NPCs)
local function isTeammateNPC(model)
    if not model then return false end
    
    -- FIRST: Make sure this is not a player character
    if Players:GetPlayerFromCharacter(model) then
        return false
    end
    
    -- THEN: Try to get NPC team information
    local teamValue = model:FindFirstChild("Team") or model:FindFirstChild("TeamValue")
    if teamValue then
        if teamValue:IsA("StringValue") then
            return teamValue.Value == (LocalPlayer.Team and LocalPlayer.Team.Name or "None")
        elseif teamValue:IsA("ObjectValue") and teamValue.Value then
            return teamValue.Value == LocalPlayer.Team
        end
    end
    
    -- Check if NPC is in the same group as local player
    if model:IsDescendantOf(LocalPlayer.Team) then
        return true
    end
    
    -- Check if NPC has the same color as local player (common in team games)
    local npcRoot = model:FindFirstChild("HumanoidRootPart")
    local localRoot = LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart")
    if npcRoot and localRoot and npcRoot.Color == localRoot.Color then
        return true
    end
    
    return false
end

local function getTeamList()
    local teamList = {}
    for _, team in ipairs(Teams:GetTeams()) do
        table.insert(teamList, team.Name)
    end
    return teamList
end

local function getPlayerList()
    local playerList = {}
    for _, player in ipairs(Players:GetPlayers()) do
        if player ~= LocalPlayer then
            table.insert(playerList, player.Name)
        end
    end
    return playerList
end

local function isFriend(player)
    local success, result = pcall(function()
        return LocalPlayer:IsFriendsWith(player.UserId)
    end)
    return success and result
end

local function shouldShowHitbox(player)
    if filters.forceIncludedPlayers[player.Name] then
        return true
    end
    if filters.excludedPlayers[player.Name] then
        return false
    end
    if player.Team and filters.excludedTeams[player.Team.Name] then
        return false
    end
    if filters.hideFriends and isFriend(player) then
        return false
    end
    
    -- New team-based filtering
    if config.hideTeammates and isTeammate(player) then
        return false
    end
    
    local char = player.Character
    if char then
        if filters.hideWhenSitting then
            local humanoid = char:FindFirstChildOfClass("Humanoid")
            if humanoid and humanoid.Sit then
                return false
            end
        end
        if filters.hideForceField and char:FindFirstChildOfClass("ForceField") then
            return false
        end
    end
    return true
end

local defaultProperties = {}

local function cacheDefaults(character)
    if not character then return end
    for _, part in pairs(character:GetChildren()) do
        if part:IsA("BasePart") then
            if not defaultProperties[part] then
                defaultProperties[part] = {
                    Size = part.Size,
                    Transparency = part.Transparency,
                    CanCollide = part.CanCollide,
                    Massless = part.Massless
                }
            end
        end
    end
end

local function resetPart(part)
    if not part then return end
    local def = defaultProperties[part]
    if def then
        part.Size = def.Size
        part.Transparency = def.Transparency
        part.CanCollide = def.CanCollide
        part.Massless = def.Massless
        part.LocalTransparencyModifier = 0
    end
end

-- MODIFIED FUNCTION: Ensures all hitboxes are walk-through
local function applyToPart(part, size, transparency, isNPC)
    if not part then return end
    
    -- Apply root attachment if enabled
    if config.attachToRoot and part.Name == "HumanoidRootPart" then
        local actualSize = isNPC and config.npcSize or config.rootSize
        local actualTransparency = isNPC and config.npcTransparency or config.transparency
        
        -- Apply invisibility
        if config.invisibleHitbox then
            part.LocalTransparencyModifier = 1
        else
            part.LocalTransparencyModifier = 0
        end
        
        -- Apply bypass techniques if enabled
        if config.bypassDetection then
            applyBypassTechniques(part, isNPC)
        else
            part.Size = Vector3.new(actualSize, actualSize, actualSize)
            part.Transparency = actualTransparency
        end
        
        -- Force walk-through for root part
        part.CanCollide = false
        part.Massless = true
        return
    end
    
    local actualSize = isNPC and config.npcSize or size
    local actualTransparency = isNPC and config.npcTransparency or transparency
    
    -- Apply invisibility to all parts including head
    if config.invisibleHitbox then
        part.LocalTransparencyModifier = 1
    else
        part.LocalTransparencyModifier = 0
    end
    
    -- Apply bypass techniques if enabled
    if config.bypassDetection then
        applyBypassTechniques(part, isNPC)
    else
        part.Size = Vector3.new(actualSize, actualSize, actualSize)
        part.Transparency = actualTransparency
    end
    
    -- Force walk-through for all hitbox parts
    part.CanCollide = false
    part.Massless = true
end

local function applyNPCHitbox(model)
    if not model then return end
    
    -- NEW: Check if we should hide all NPC hitboxes
    if config.hideNPCHitboxes then
        for _, partsList in pairs(hitboxPartsMap) do
            for _, partName in ipairs(partsList) do
                local part = model:FindFirstChild(partName)
                if part then
                    resetPart(part)
                end
            end
        end
        return
    end
    
    -- NEW: Check if we should hide teammate NPCs
    if config.hideTeammateNPCs and isTeammateNPC(model) then
        for _, partsList in pairs(hitboxPartsMap) do
            for _, partName in ipairs(partsList) do
                local part = model:FindFirstChild(partName)
                if part then
                    resetPart(part)
                end
            end
        end
        return
    end
    
    local humanoid = model:FindFirstChildOfClass("Humanoid")
    if not humanoid or humanoid.Health <= 0 then
        for _, partsList in pairs(hitboxPartsMap) do
            for _, partName in ipairs(partsList) do
                local part = model:FindFirstChild(partName)
                if part then
                    resetPart(part)
                end
            end
        end
        return
    end

    -- Add visibility check for NPCs
    local isNPCVisible = visibilityCache[model] or true
    if config.legitMode and config.npcEnabled then
        isNPCVisible = visibilityCache[model] or false
    end

    if not config.enabled or not config.npcEnabled or not isNPCVisible then
        for _, partsList in pairs(hitboxPartsMap) do
            for _, partName in ipairs(partsList) do
                local part = model:FindFirstChild(partName)
                if part then
                    resetPart(part)
                end
            end
        end
        return
    end

    cacheDefaults(model)
    
    -- Handle root attachment for NPCs
    if config.attachToRoot then
        local rootPart = model:FindFirstChild("HumanoidRootPart")
        if rootPart then
            applyToPart(rootPart, config.rootSize, config.transparency, true)
        end
        return
    end

    for hitboxType, enabled in pairs(hitboxToggles) do
        local partsList = hitboxPartsMap[hitboxType]
        if enabled and partsList then
            for _, partName in ipairs(partsList) do
                local part = model:FindFirstChild(partName)
                if part then
                    applyToPart(part, config.size, config.transparency, true)
                end
            end
        else
            if partsList then
                for _, partName in ipairs(partsList) do
                    local part = model:FindFirstChild(partName)
                    if part then
                        resetPart(part)
                    end
                end
            end
        end
    end
end

local function applyHitbox(player)
    if player == LocalPlayer then return end

    if not monitoredPlayers[player] then
        monitoredPlayers[player] = true

        player.CharacterAdded:Connect(function(char)
            char:WaitForChild("Humanoid", 5)
            local humanoid = char:FindFirstChildOfClass("Humanoid")
            if humanoid then
                humanoid:GetPropertyChangedSignal("Sit"):Connect(function()
                    applyHitbox(player)
                end)
            end
            char.ChildAdded:Connect(function(child)
                if child:IsA("ForceField") then
                    applyHitbox(player)
                end
            end)
            char.ChildRemoved:Connect(function(child)
                if child:IsA("ForceField") then
                    applyHitbox(player)
                end
            end)
            task.wait(0.2)
            applyHitbox(player)
        end)

        if player.Character then
            local humanoid = player.Character:FindFirstChildOfClass("Humanoid")
            if humanoid then
                humanoid:GetPropertyChangedSignal("Sit"):Connect(function()
                    applyHitbox(player)
                end)
            end
            player.Character.ChildAdded:Connect(function(child)
                if child:IsA("ForceField") then
                    applyHitbox(player)
                end
            end)
            player.Character.ChildRemoved:Connect(function(child)
                if child:IsA("ForceField") then
                    applyHitbox(player)
                end
            end)
            task.delay(0.3, function()
                applyHitbox(player)
            end)
        end
    end

    local char = player.Character
    if not char then return end

    local humanoid = char:FindFirstChildOfClass("Humanoid")
    if not humanoid or humanoid.Health <= 0 then
        for _, partsList in pairs(hitboxPartsMap) do
            for _, partName in ipairs(partsList) do
                local part = char:FindFirstChild(partName)
                if part then
                    resetPart(part)
                end
            end
        end
        return
    end

    -- Use cached visibility
    local isPlayerVisible = visibilityCache[player] or true
    if config.legitMode then
        isPlayerVisible = visibilityCache[player] or false
    end

    if not config.enabled or not shouldShowHitbox(player) or not isPlayerVisible then
        for _, partsList in pairs(hitboxPartsMap) do
            for _, partName in ipairs(partsList) do
                local part = char:FindFirstChild(partName)
                if part then
                    resetPart(part)
                end
            end
        end
        return
    end

    cacheDefaults(char)
    
    -- Handle root attachment for players
    if config.attachToRoot then
        local rootPart = char:FindFirstChild("HumanoidRootPart")
        if rootPart then
            applyToPart(rootPart, config.rootSize, config.transparency, false)
        end
        return
    end

    for hitboxType, enabled in pairs(hitboxToggles) do
        local partsList = hitboxPartsMap[hitboxType]
        if enabled and partsList then
            for _, partName in ipairs(partsList) do
                local part = char:FindFirstChild(partName)
                if part then
                    applyToPart(part, config.size, config.transparency, false)
                end
            end
        else
            if partsList then
                for _, partName in ipairs(partsList) do
                    local part = char:FindFirstChild(partName)
                    if part then
                        resetPart(part)
                    end
                end
            end
        end
    end
end

local function updateAllHitboxes()
    for player, _ in pairs(monitoredPlayers) do
        applyHitbox(player)
    end
    for model, _ in pairs(npcTracker.activeNPCs) do
        applyNPCHitbox(model)
    end
end

-- NPC tracking system
local npcList = {}

local function trackNPC(part)
    if part:IsA("BasePart") and part.Name == "HumanoidRootPart" then
        local model = part.Parent
        if model:IsA("Model") and model:FindFirstChildOfClass("Humanoid") and 
           not Players:GetPlayerFromCharacter(model) and not npcTracker.activeNPCs[model] then
            
            table.insert(npcList, model)
            npcTracker.activeNPCs[model] = true
            
            local humanoid = model:FindFirstChildOfClass("Humanoid")
            if humanoid then
                local healthConn = humanoid:GetPropertyChangedSignal("Health"):Connect(function()
                    applyNPCHitbox(model)
                end)
                
                local diedConn = humanoid.Died:Connect(function()
                    applyNPCHitbox(model)
                    
                    local respawnConn
                    respawnConn = model.AncestryChanged:Connect(function(_, parent)
                        if parent == Workspace then
                            task.wait(0.1)
                            applyNPCHitbox(model)
                            respawnConn:Disconnect()
                        end
                    end)
                end)
                
                npcTracker.connections[model] = {
                    healthConn,
                    diedConn
                }
            end
            
            local ancestryConn = model.AncestryChanged:Connect(function(_, parent)
                if not parent then
                    if npcTracker.connections[model] then
                        for _, conn in ipairs(npcTracker.connections[model]) do
                            conn:Disconnect()
                        end
                    end
                    npcTracker.activeNPCs[model] = nil
                    npcTracker.connections[model] = nil
                    
                    for i, npc in ipairs(npcList) do
                        if npc == model then
                            table.remove(npcList, i)
                            break
                        end
                    end
                end
            end)
            
            table.insert(npcTracker.connections[model], ancestryConn)
            
            applyNPCHitbox(model)
        end
    end
end

-- Initialize NPC monitoring
local function setupNPCMonitoring()
    for _, part in ipairs(Workspace:GetDescendants()) do
        trackNPC(part)
    end

    Workspace.DescendantAdded:Connect(trackNPC)
end

-- ESP system
local function createHighlight(character, color)
    if not character then return nil end
    
    local highlight = Instance.new("Highlight")
    highlight.Adornee = character
    highlight.DepthMode = Enum.HighlightDepthMode.AlwaysOnTop
    highlight.FillColor = color
    highlight.FillTransparency = 0.5
    highlight.OutlineColor = color
    highlight.OutlineTransparency = 0
    highlight.Parent = character
    
    return highlight
end

local function createBillboard(character)
    if not character then return nil end
    
    local head = character:FindFirstChild("Head")
    local humanoidRootPart = character:FindFirstChild("HumanoidRootPart")
    local primaryPart = character.PrimaryPart
    
    local adornee = head or humanoidRootPart or primaryPart
    if not adornee then return nil end
    
    local billboard = Instance.new("BillboardGui")
    billboard.Adornee = adornee
    billboard.Size = UDim2.new(0, 200, 0, 100)
    billboard.StudsOffset = Vector3.new(0, 4, 0)
    billboard.AlwaysOnTop = true
    billboard.Parent = character
    
    local nameLabel = Instance.new("TextLabel")
    nameLabel.Name = "NameLabel"
    nameLabel.Size = UDim2.new(1, 0, 0.25, 0)
    nameLabel.Position = UDim2.new(0, 0, 0, 0)
    nameLabel.BackgroundTransparency = 1
    nameLabel.TextColor3 = espConfig.textColor
    nameLabel.TextSize = 14
    nameLabel.Text = "Player"
    nameLabel.Visible = espConfig.nameEnabled and espConfig.enabled
    nameLabel.Parent = billboard
    
    local healthLabel = Instance.new("TextLabel")
    healthLabel.Name = "HealthLabel"
    healthLabel.Size = UDim2.new(1, 0, 0.25, 0)
    healthLabel.Position = UDim2.new(0, 0, 0.25, 0)
    healthLabel.BackgroundTransparency = 1
    healthLabel.TextColor3 = espConfig.textColor
    healthLabel.TextSize = 12
    healthLabel.Text = "HP: 100/100"
    healthLabel.Visible = espConfig.healthEnabled and espConfig.enabled
    healthLabel.Parent = billboard
    
    local teamLabel = Instance.new("TextLabel")
    teamLabel.Name = "TeamLabel"
    teamLabel.Size = UDim2.new(1, 0, 0.25, 0)
    teamLabel.Position = UDim2.new(0, 0, 0.5, 0)
    teamLabel.BackgroundTransparency = 1
    teamLabel.TextColor3 = espConfig.teamColor
    teamLabel.TextSize = 12
    teamLabel.Text = "Team: None"
    teamLabel.Visible = espConfig.teamEnabled and espConfig.enabled
    teamLabel.Parent = billboard
    
    local heldItemLabel = Instance.new("TextLabel")
    heldItemLabel.Name = "HeldItemLabel"
    heldItemLabel.Size = UDim2.new(1, 0, 0.25, 0)
    heldItemLabel.Position = UDim2.new(0, 0, 0.75, 0)
    heldItemLabel.BackgroundTransparency = 1
    heldItemLabel.TextColor3 = espConfig.heldItemColor
    heldItemLabel.TextSize = 12
    heldItemLabel.Text = "Holding: None"
    heldItemLabel.Visible = espConfig.heldItemEnabled and espConfig.enabled
    heldItemLabel.Parent = billboard
    
    return billboard
end

local function getHeldItem(player)
    if not player.Character then return "None" end
    
    local humanoid = player.Character:FindFirstChildOfClass("Humanoid")
    if humanoid then
        local equippedTool = humanoid:FindFirstChildOfClass("Tool")
        if equippedTool then
            return equippedTool.Name
        end
    end
    
    local rightHand = player.Character:FindFirstChild("RightHand") or player.Character:FindFirstChild("Right Arm")
    if rightHand then
        for _, child in ipairs(rightHand:GetChildren()) do
            if child:IsA("Tool") or child:IsA("Part") then
                return child.Name
            end
        end
    end
    
    local leftHand = player.Character:FindFirstChild("LeftHand") or player.Character:FindFirstChild("Left Arm")
    if leftHand then
        for _, child in ipairs(leftHand:GetChildren()) do
            if child:IsA("Tool") or child:IsA("Part") then
                return child.Name
            end
        end
    end
    
    return "None"
end

-- ========================================================================
-- IMPROVED ESP SYSTEM WITH IMMEDIATE HIGHLIGHT ON RESPAWN/SPAWN
-- ========================================================================
local function setupPlayerEsp(player)
    if not player or player == LocalPlayer then return end
    
    -- Cleanup existing ESP
    if espData.players[player] then
        for _, conn in ipairs(espData.players[player].connections) do
            conn:Disconnect()
        end
        if espData.players[player].highlight then
            espData.players[player].highlight:Destroy()
        end
        if espData.players[player].billboard then
            espData.players[player].billboard:Destroy()
        end
    end
    
    espData.players[player] = {
        highlight = nil,
        billboard = nil,
        connections = {}
    }
    
    local data = espData.players[player]
    
    -- Function to apply ESP immediately to a character
    local function applyEspToCharacter(char)
        if not char or not char.Parent then return end
        
        -- Immediately create highlight if enabled
        if espConfig.enabled and espConfig.highlightEnabled then
            data.highlight = createHighlight(char, espConfig.highlightColor)
            data.highlight.Enabled = true
        end
        
        -- Immediately create billboard if enabled
        if espConfig.enabled then
            data.billboard = createBillboard(char)
            if data.billboard:FindFirstChild("NameLabel") then
                data.billboard.NameLabel.Text = player.Name
                data.billboard.NameLabel.Visible = espConfig.nameEnabled
            end
            if data.billboard:FindFirstChild("TeamLabel") then
                data.billboard.TeamLabel.Text = "Team: " .. (player.Team and player.Team.Name or "None")
                data.billboard.TeamLabel.Visible = espConfig.teamEnabled
            end
            data.billboard.Enabled = true
        end
        
        -- Setup health tracking
        local humanoid = char:FindFirstChildOfClass("Humanoid")
        if humanoid then
            local healthConn = humanoid:GetPropertyChangedSignal("Health"):Connect(function()
                if data.billboard and data.billboard:FindFirstChild("HealthLabel") then
                    data.billboard.HealthLabel.Text = string.format("HP: %d/%d", humanoid.Health, humanoid.MaxHealth)
                end
            end)
            table.insert(data.connections, healthConn)
            
            -- Handle death and respawn
            local diedConn = humanoid.Died:Connect(function()
                if data.highlight then
                    data.highlight:Destroy()
                    data.highlight = nil
                end
                if data.billboard then
                    data.billboard:Destroy()
                    data.billboard = nil
                end
            end)
            table.insert(data.connections, diedConn)
        end
        
        -- Team change connection
        local teamConn = player:GetPropertyChangedSignal("Team"):Connect(function()
            if data.billboard and data.billboard:FindFirstChild("TeamLabel") then
                data.billboard.TeamLabel.Text = "Team: " .. (player.Team and player.Team.Name or "None")
            end
            -- Also update ESP immediately when team changes
            updatePlayerEsp(player)
        end)
        table.insert(data.connections, teamConn)
        
        -- Held item tracking
        local function updateHeldItem()
            if data.billboard and data.billboard:FindFirstChild("HeldItemLabel") then
                data.billboard.HeldItemLabel.Text = "Holding: " .. getHeldItem(player)
            end
        end
        
        local backpack = player:FindFirstChild("Backpack")
        if backpack then
            local backpackConn = backpack.ChildAdded:Connect(updateHeldItem)
            table.insert(data.connections, backpackConn)
            
            local backpackRemovedConn = backpack.ChildRemoved:Connect(updateHeldItem)
            table.insert(data.connections, backpackRemovedConn)
        end
        
        local charToolConn = char.ChildAdded:Connect(function(child)
            if child:IsA("Tool") then
                updateHeldItem()
            end
        end)
        table.insert(data.connections, charToolConn)
        
        local charToolRemovedConn = char.ChildRemoved:Connect(function(child)
            if child:IsA("Tool") then
                updateHeldItem()
            end
        end)
        table.insert(data.connections, charToolRemovedConn)
        
        -- Immediate connection to reapply ESP when character respawns
        local function onCharacterDescendant(descendant)
            if descendant:IsA("BasePart") then
                -- Reapply highlight to any new body parts
                if data.highlight then
                    data.highlight.Adornee = char
                end
            end
        end
        
        char.DescendantAdded:Connect(onCharacterDescendant)
        table.insert(data.connections, char.DescendantAdded:Connect(onCharacterDescendant))
    end
    
    -- Direct connection to apply ESP as soon as character appears
    local function onCharacterAdded(char)
        -- Wait for character to fully load
        local rootPart = char:WaitForChild("HumanoidRootPart", 3)
        local humanoid = char:WaitForChild("Humanoid", 3)
        
        if rootPart and humanoid then
            applyEspToCharacter(char)
        else
            -- Retry if character didn't load properly
            task.spawn(function()
                task.wait(0.5)
                if char:IsDescendantOf(Workspace) then
                    applyEspToCharacter(char)
                end
            end)
        end
    end
    
    -- Apply to existing character immediately
    if player.Character then
        onCharacterAdded(player.Character)
    end
    
    -- Connect to future character additions
    local charAddedConn = player.CharacterAdded:Connect(onCharacterAdded)
    table.insert(data.connections, charAddedConn)
    
    -- Cleanup when player leaves
    local playerRemovingConn = player.AncestryChanged:Connect(function(_, parent)
        if not parent then
            if data.highlight then data.highlight:Destroy() end
            if data.billboard then data.billboard:Destroy() end
            for _, conn in ipairs(data.connections) do conn:Disconnect() end
            espData.players[player] = nil
        end
    end)
    table.insert(data.connections, playerRemovingConn)
end

local function updateItemEsp()
    if not espConfig.enabled or not espConfig.itemEspEnabled then
        for item, itemData in pairs(espData.items) do
            if itemData.highlight then itemData.highlight:Destroy() end
            if itemData.billboard then itemData.billboard:Destroy() end
        end
        espData.items = {}
        return
    end
    
    local trackedItems = {}
    for _, itemName in ipairs(espConfig.trackedItems) do
        trackedItems[itemName:lower()] = true
    end
    
    for _, instance in ipairs(Workspace:GetDescendants()) do
        if not espData.items[instance] and trackedItems[instance.Name:lower()] then
            local highlight = createHighlight(instance, espConfig.itemColor)
            highlight.Enabled = true
            
            local billboard = Instance.new("BillboardGui")
            billboard.Adornee = instance
            billboard.Size = UDim2.new(0, 150, 0, 30)
            billboard.StudsOffset = Vector3.new(0, 2, 0)
            billboard.AlwaysOnTop = true
            billboard.Enabled = true
            billboard.Parent = instance
            
            local itemLabel = Instance.new("TextLabel")
            itemLabel.Size = UDim2.new(1, 0, 1, 0)
            itemLabel.BackgroundTransparency = 1
            itemLabel.TextColor3 = espConfig.itemColor
            itemLabel.TextSize = 12
            itemLabel.Text = instance.Name
            itemLabel.Parent = billboard
            
            espData.items[instance] = {
                highlight = highlight,
                billboard = billboard
            }
        end
    end
    
    for item, itemData in pairs(espData.items) do
        if not item:IsDescendantOf(Workspace) then
            if itemData.highlight then itemData.highlight:Destroy() end
            if itemData.billboard then itemData.billboard:Destroy() end
            espData.items[item] = nil
        end
    end
end

-- Function to update ESP for a specific player
local function updatePlayerEsp(player)
    if not espData.players[player] then return end
    
    local data = espData.players[player]
    local char = player.Character
    
    local teamExcluded = false
    if player.Team and espFilters.excludedTeams[player.Team.Name] then
        teamExcluded = true
    end
    
    local playerExcluded = espFilters.excludedPlayers[player.Name]
    
    -- Destroy existing ESP elements if character is missing
    if not char then
        if data.highlight then
            data.highlight:Destroy()
            data.highlight = nil
        end
        if data.billboard then
            data.billboard:Destroy()
            data.billboard = nil
        end
    else
        if data.highlight then
            data.highlight.Enabled = espConfig.enabled and espConfig.highlightEnabled and not teamExcluded and not playerExcluded
            data.highlight.FillColor = espConfig.highlightColor
            data.highlight.OutlineColor = espConfig.highlightColor
        end
        
        if data.billboard then
            data.billboard.Enabled = espConfig.enabled and not teamExcluded and not playerExcluded
            
            if data.billboard:FindFirstChild("NameLabel") then
                data.billboard.NameLabel.Visible = espConfig.nameEnabled
                data.billboard.NameLabel.TextColor3 = espConfig.textColor
            end
            
            if data.billboard:FindFirstChild("HealthLabel") then
                data.billboard.HealthLabel.Visible = espConfig.healthEnabled
                data.billboard.HealthLabel.TextColor3 = espConfig.textColor
                local humanoid = char:FindFirstChildOfClass("Humanoid")
                if humanoid then
                    data.billboard.HealthLabel.Text = string.format("HP: %d/%d", humanoid.Health, humanoid.MaxHealth)
                end
            end
            
            if data.billboard:FindFirstChild("TeamLabel") then
                data.billboard.TeamLabel.Visible = espConfig.teamEnabled
                data.billboard.TeamLabel.TextColor3 = espConfig.teamColor
                data.billboard.TeamLabel.Text = "Team: " .. (player.Team and player.Team.Name or "None")
            end
            
            if data.billboard:FindFirstChild("HeldItemLabel") then
                data.billboard.HeldItemLabel.Visible = espConfig.heldItemEnabled
                data.billboard.HeldItemLabel.TextColor3 = espConfig.heldItemColor
                data.billboard.HeldItemLabel.Text = "Holding: " .. getHeldItem(player)
            end
        end
        
        -- Always recreate ESP elements if they're missing and ESP is enabled
        if espConfig.enabled and not teamExcluded and not playerExcluded then
            if espConfig.highlightEnabled and not data.highlight then
                data.highlight = createHighlight(char, espConfig.highlightColor)
            end
            if not data.billboard then
                data.billboard = createBillboard(char)
                if data.billboard:FindFirstChild("NameLabel") then
                    data.billboard.NameLabel.Text = player.Name
                end
                if data.billboard:FindFirstChild("TeamLabel") then
                    data.billboard.TeamLabel.Text = "Team: " .. (player.Team and player.Team.Name or "None")
                end
            end
        end
    end
end

local function updateAllEsp()
    for _, player in ipairs(Players:GetPlayers()) do
        updatePlayerEsp(player)
    end
    
    updateItemEsp()
end

local function initializeEsp()
    for _, player in ipairs(Players:GetPlayers()) do
        if player ~= LocalPlayer then
            setupPlayerEsp(player)
        end
    end
    
    Players.PlayerAdded:Connect(function(player)
        if player ~= LocalPlayer then
            setupPlayerEsp(player)
        end
    end)
    
    Workspace.DescendantAdded:Connect(function(descendant)
        if espConfig.enabled and espConfig.itemEspEnabled then
            updateItemEsp()
        end
    end)
    
    updateItemEsp()
end

initializeEsp()

-- MainTab Controls
MainTab:CreateToggle({
    Name = "Enable Hitbox Expander",
    CurrentValue = config.enabled,
    Flag = "HitboxToggle",
    Callback = function(Value)
        config.enabled = Value
        updateAllHitboxes()
    end,
})

MainTab:CreateToggle({
    Name = "Enable NPC Hitboxes",
    CurrentValue = config.npcEnabled,
    Flag = "NPCToggle",
    Callback = function(Value)
        config.npcEnabled = Value
        updateAllHitboxes()
    end,
})

MainTab:CreateLabel("Player Settings")
MainTab:CreateSlider({
    Name = "Hitbox Size",
    Range = {2, 200},
    Increment = 1,
    Suffix = "Size",
    CurrentValue = config.size,
    Flag = "SizeSlider",
    Callback = function(Value)
        config.size = Value
        updateAllHitboxes()
    end,
})

MainTab:CreateSlider({
    Name = "Transparency",
    Range = {0, 1},
    Increment = 0.05,
    Suffix = "",
    CurrentValue = config.transparency,
    Flag = "TransparencySlider",
    Callback = function(Value)
        config.transparency = Value
        updateAllHitboxes()
    end,
})

MainTab:CreateToggle({
    Name = "Enable Collide (Players)",
    CurrentValue = config.collideEnabled,
    Flag = "CollideToggle",
    Callback = function(Value)
        config.collideEnabled = Value
        updateAllHitboxes()
    end,
})

MainTab:CreateLabel("NPC Settings")
MainTab:CreateSlider({
    Name = "NPC Hitbox Size",
    Range = {2, 200},
    Increment = 1,
    Suffix = "Size",
    CurrentValue = config.npcSize,
    Flag = "NPCSizeSlider",
    Callback = function(Value)
        config.npcSize = Value
        updateAllHitboxes()
    end,
})

MainTab:CreateSlider({
    Name = "NPC Transparency",
    Range = {0, 1},
    Increment = 0.05,
    Suffix = "",
    CurrentValue = config.npcTransparency,
    Flag = "NPCTransparencySlider",
    Callback = function(Value)
        config.npcTransparency = Value
        updateAllHitboxes()
    end,
})

MainTab:CreateToggle({
    Name = "Enable Collide (NPCs)",
    CurrentValue = config.npcCollideEnabled,
    Flag = "NPCCollideToggle",
    Callback = function(Value)
        config.npcCollideEnabled = Value
        updateAllHitboxes()
    end,
})

MainTab:CreateToggle({
    Name = "Bypass Hitbox Detection",
    CurrentValue = config.bypassDetection,
    Flag = "BypassDetectionToggle",
    Callback = function(Value)
        config.bypassDetection = Value
        updateAllHitboxes()
        
        if Value then
            local methodsList = table.concat(config.bypassMethods, ", ")
            Rayfield:Notify({
                Title = "Bypass Enabled",
                Content = "Using: "..methodsList,
                Duration = 3,
                Image = 4483362458
            })
        end
    end,
})

MainTab:CreateDropdown({
    Name = "Bypass Methods",
    Options = bypassMethodsList,
    CurrentOption = config.bypassMethods,
    MultipleOptions = true,
    Flag = "BypassMethodDropdown",
    Callback = function(SelectedMethods)
        config.bypassMethods = SelectedMethods
        
        if config.bypassDetection then
            local methodsList = table.concat(SelectedMethods, ", ")
            Rayfield:Notify({
                Title = "Bypass Methods Changed",
                Content = "Now using: "..methodsList,
                Duration = 3,
                Image = 4483362458
            })
            updateAllHitboxes()
        end
    end,
})

MainTab:CreateLabel("Bypass Techniques")
MainTab:CreateParagraph({
    Title = "Detection Evasion Methods",
    Content = "Size Variation: Randomly scales hitbox size\nTransparency Variation: Randomly adjusts transparency\nPosition Offset: Slightly offsets hitbox position\nDynamic Scaling: Smoothly scales hitbox size over time"
})

MainTab:CreateToggle({
    Name = "Invisible Hitboxes",
    CurrentValue = config.invisibleHitbox,
    Flag = "InvisibleHitboxToggle",
    Callback = function(Value)
        config.invisibleHitbox = Value
        updateAllHitboxes()
        
        if Value then
            Rayfield:Notify({
                Title = "Invisible Hitboxes Enabled",
                Content = "All hitboxes are now invisible",
                Duration = 3,
                Image = 4483362458
            })
        else
            Rayfield:Notify({
                Title = "Invisible Hitboxes Disabled",
                Content = "Hitboxes are now visible",
                Duration = 3,
                Image = 4483362458
            })
        end
    end,
})

-- Legit mode controls
MainTab:CreateToggle({
    Name = "Legit Hitbox (No Wallbang)",
    CurrentValue = config.legitMode,
    Flag = "LegitModeToggle",
    Callback = function(Value)
        config.legitMode = Value
        visibilityCache = {} -- Reset visibility cache
        
        if Value then
            Rayfield:Notify({
                Title = "Legit Mode Enabled",
                Content = "Hitboxes will dynamically update based on visibility",
                Duration = 3,
                Image = 4483362458
            })
        else
            Rayfield:Notify({
                Title = "Legit Mode Disabled",
                Content = "Hitboxes will always be visible",
                Duration = 3,
                Image = 4483362458
            })
        end
        
        updateAllHitboxes()
    end,
})

-- Off-wall detection slider
MainTab:CreateSlider({
    Name = "Off-Wall Detection",
    Range = {0, 1},
    Increment = 0.1,
    Suffix = "Threshold",
    CurrentValue = config.offWallThreshold,
    Flag = "OffWallSlider",
    Callback = function(Value)
        config.offWallThreshold = Value
        Rayfield:Notify({
            Title = "Off-Wall Detection Updated",
            Content = "Threshold set to " .. Value,
            Duration = 3,
            Image = 4483362458
        })
    end,
})

local hitboxPartsOptions = {}
for partName, _ in pairs(hitboxToggles) do
    table.insert(hitboxPartsOptions, partName)
end

local defaultSelected = {}
for partName, enabled in pairs(hitboxToggles) do
    if enabled then
        table.insert(defaultSelected, partName)
    end
end

MainTab:CreateDropdown({
    Name = "Hitbox Parts",
    Options = hitboxPartsOptions,
    CurrentOption = defaultSelected,
    MultipleOptions = true,
    Flag = "HitboxPartsDropdown",
    Callback = function(selectedParts)
        for partName, _ in pairs(hitboxToggles) do
            hitboxToggles[partName] = false
        end
        for _, partName in ipairs(selectedParts) do
            hitboxToggles[partName] = true
        end
        updateAllHitboxes()
    end,
})

-- NEW: RootPart hitbox section
MainTab:CreateSection("RootPart Hitbox")

MainTab:CreateToggle({
    Name = "Attach to RootPart",
    CurrentValue = config.attachToRoot,
    Flag = "AttachRootToggle",
    Callback = function(Value)
        config.attachToRoot = Value
        updateAllHitboxes()
        
        if Value then
            Rayfield:Notify({
                Title = "RootPart Hitbox Enabled",
                Content = "Hitboxes are now attached to HumanoidRootPart",
                Duration = 3,
                Image = 4483362458
            })
        else
            Rayfield:Notify({
                Title = "RootPart Hitbox Disabled",
                Content = "Hitboxes are back on body parts",
                Duration = 3,
                Image = 4483362458
            })
        end
    end,
})

MainTab:CreateSlider({
    Name = "RootPart Size",
    Range = {2, 200},
    Increment = 1,
    Suffix = "Size",
    CurrentValue = config.rootSize,
    Flag = "RootSizeSlider",
    Callback = function(Value)
        config.rootSize = Value
        if config.attachToRoot then
            updateAllHitboxes()
        end
    end,
})

MainTab:CreateParagraph({
    Title = "RootPart Hitbox Info",
    Content = "Attaches all hitboxes to the HumanoidRootPart instead of individual body parts. Provides a single large hitbox at the character's center."
})

-- FilterTab
local playerDropdown = FilterTab:CreateDropdown({
    Name = "Exclude Players",
    Options = getPlayerList(),
    CurrentOption = "",
    MultipleOptions = true,
    Flag = "PlayerFilterDropdown",
    Callback = function(Selected)
        filters.excludedPlayers = {}
        for _, playerName in ipairs(Selected) do
            filters.excludedPlayers[playerName] = true
        end
        updateAllHitboxes()
    end,
})

local teamDropdown = FilterTab:CreateDropdown({
    Name = "Exclude Teams",
    Options = getTeamList(),
    CurrentOption = "",
    MultipleOptions = true,
    Flag = "TeamFilterDropdown",
    Callback = function(Selected)
        filters.excludedTeams = {}
        for _, teamName in ipairs(Selected) do
            filters.excludedTeams[teamName] = true
        end
        updateAllHitboxes()
    end,
})

local forceIncludeDropdown = FilterTab:CreateDropdown({
    Name = "Force Include Players",
    Options = getPlayerList(),
    CurrentOption = "",
    MultipleOptions = true,
    Flag = "ForceIncludeDropdown",
    Callback = function(Selected)
        filters.forceIncludedPlayers = {}
        for _, playerName in ipairs(Selected) do
            filters.forceIncludedPlayers[playerName] = true
        end
        updateAllHitboxes()
    end,
})

-- NEW: Hide Teammates toggle
FilterTab:CreateToggle({
    Name = "Hide Teammates",
    CurrentValue = config.hideTeammates,
    Flag = "HideTeammatesToggle",
    Callback = function(Value)
        config.hideTeammates = Value
        updateAllHitboxes()
    end
})

FilterTab:CreateToggle({
    Name = "Hide Hitbox When Player is Sitting",
    CurrentValue = filters.hideWhenSitting,
    Flag = "HideSittingToggle",
    Callback = function(Value)
        filters.hideWhenSitting = Value
        updateAllHitboxes()
    end
})

FilterTab:CreateToggle({
    Name = "Hide Hitbox for Friends",
    CurrentValue = filters.hideFriends,
    Flag = "HideFriendsToggle",
    Callback = function(Value)
        filters.hideFriends = Value
        updateAllHitboxes()
    end
})

FilterTab:CreateToggle({
    Name = "Hide Hitbox for Players with ForceField",
    CurrentValue = filters.hideForceField,
    Flag = "HideForceFieldToggle",
    Callback = function(Value)
        filters.hideForceField = Value
        updateAllHitboxes()
    end
})

-- NEW: NPC Filter Section
FilterTab:CreateSection("NPC Filters")

FilterTab:CreateToggle({
    Name = "Hide All NPC Hitboxes",
    CurrentValue = config.hideNPCHitboxes,
    Flag = "HideAllNPCToggle",
    Callback = function(Value)
        config.hideNPCHitboxes = Value
        updateAllHitboxes()
    end
})

FilterTab:CreateToggle({
    Name = "Hide Teammate NPCs",
    CurrentValue = config.hideTeammateNPCs,
    Flag = "HideTeammateNPCToggle",
    Callback = function(Value)
        config.hideTeammateNPCs = Value
        updateAllHitboxes()
    end
})

FilterTab:CreateSection("ESP Filters")

FilterTab:CreateDropdown({
    Name = "Exclude Teams from ESP",
    Options = getTeamList(),
    CurrentOption = "",
    MultipleOptions = true,
    Flag = "EspTeamFilterDropdown",
    Callback = function(Selected)
        espFilters.excludedTeams = {}
        for _, teamName in ipairs(Selected) do
            espFilters.excludedTeams[teamName] = true
        end
        updateAllEsp()
    end,
})

-- ScriptTab Buttons
ScriptTab:CreateButton({
    Name = "Load Shiftlock Script",
    Callback = function()
        loadstring(game:HttpGet("https://raw.githubusercontent.com/prosadaf/Example/refs/heads/main/Video"))()
    end,
})

-- NEW FLY SCRIPT BUTTON ADDED HERE
ScriptTab:CreateButton({
    Name = "Load Fly Script",
    Callback = function()
        loadstring(game:HttpGet(('https://pastebin.com/raw/TSjdP9mj'),true))()
        Rayfield:Notify({
            Title = "Fly Script Loaded",
            Content = "Press 'E' to toggle flight!",
            Duration = 5,
            Image = 4483362458
        })
    end,
})

ScriptTab:CreateButton({
    Name = "Load Infinite Yield",
    Callback = function()
        loadstring(game:HttpGet('https://raw.githubusercontent.com/EdgeIY/infiniteyield/master/source'))()
    end,
})

ScriptTab:CreateButton({
    Name = "Load Adonis Bypasser",
    Callback = function()
        loadstring(game:HttpGet("https://rawscripts.net/raw/Universal-Script-Adonis-Admin-Anti-Crash-18757"))()
    end,
})

ScriptTab:CreateButton({
    Name = "Load Abcde Bypasser",
    Callback = function()
        game:GetService("RunService").Heartbeat:Connect(function()
            task.wait(0.1)
            local char = game.Players.LocalPlayer.Character
            if char and char:FindFirstChild("abcde") then
                char.abcde:Destroy()
            end
        end)
    end,
})

ScriptTab:CreateButton({
    Name = "Load Instant Proximity",
    Callback = function()
        local ProximityPromptHoldDuration = 0
        local ChangedObjects = {}

        for _, ProximityObject in ipairs(workspace:GetDescendants()) do
            if ProximityObject:IsA("ProximityPrompt") then
                ChangedObjects[ProximityObject] = ProximityObject.HoldDuration
                ProximityObject.HoldDuration = ProximityPromptHoldDuration
            end
        end
    end,
})

ScriptTab:CreateButton({
    Name = "Load Anti-Afk",
    Callback = function()
        loadstring(game:HttpGet("https://raw.githubusercontent.com/KazeOnTop/Rice-Anti-Afk/main/Wind", true))()
        Rayfield:Notify({
            Title = "Anti-Afk Loaded",
            Content = "Anti-Afk protection has been enabled!",
            Duration = 5,
            Image = 4483362458
        })
    end,
})

-- ANTI-KICK BUTTON ADDED HERE
ScriptTab:CreateButton({
    Name = "Load Anti-Kick",
    Callback = function()
        loadstring(game:HttpGet("https://raw.githubusercontent.com/Exunys/Anti-Kick/main/Anti-Kick.lua"))()
        Rayfield:Notify({
            Title = "Anti-Kick Loaded",
            Content = "Kick protection has been enabled!",
            Duration = 5,
            Image = 4483362458
        })
    end,
})

-- Walkspeed Changer
ScriptTab:CreateSection("Walkspeed Changer (Detected in most games)")

local walkspeedConfig = {
    enabled = false,
    speed = 16
}

ScriptTab:CreateInput({
    Name = "Walkspeed Value",
    PlaceholderText = tostring(walkspeedConfig.speed),
    RemoveTextAfterFocusLost = false,
    Callback = function(Text)
        local num = tonumber(Text)
        if num and num > 0 then
            walkspeedConfig.speed = num
            Rayfield:Notify({
                Title = "Walkspeed Set",
                Content = "Walkspeed set to " .. num,
                Duration = 3,
                Image = 4483362458
            })
        else
            Rayfield:Notify({
                Title = "Invalid Input",
                Content = "Please enter a positive number",
                Duration = 3,
                Image = 4483362458
            })
        end
    end,
})

ScriptTab:CreateToggle({
    Name = "Enable Walkspeed Changer",
    CurrentValue = walkspeedConfig.enabled,
    Flag = "WalkSpeedToggle",
    Callback = function(Value)
        walkspeedConfig.enabled = Value
    end,
})

local function applyWalkspeed()
    if not walkspeedConfig.enabled then return end
    
    local char = LocalPlayer.Character
    if char then
        local humanoid = char:FindFirstChildOfClass("Humanoid")
        if humanoid then
            pcall(function()
                humanoid.WalkSpeed = walkspeedConfig.speed
            end)
        end
    end
end

LocalPlayer.CharacterAdded:Connect(function(char)
    if walkspeedConfig.enabled then
        char:WaitForChild("Humanoid", 5)
        applyWalkspeed()
    end
end)

task.spawn(function()
    while true do
        if walkspeedConfig.enabled then
            applyWalkspeed()
        end
        task.wait(0.1)
    end
end)

-- Tpwalk
ScriptTab:CreateSection("Teleport Walkspeed (Less detectable)")

local tpWalkConfig = {
    enabled = false,
    value = 1,
    allowNegative = false
}

ScriptTab:CreateInput({
    Name = "Tpwalk Value",
    PlaceholderText = tostring(tpWalkConfig.value),
    RemoveTextAfterFocusLost = false,
    Callback = function(Text)
        local num = tonumber(Text)
        if num then
            if tpWalkConfig.allowNegative then
                if num ~= 0 then
                    tpWalkConfig.value = num
                    Rayfield:Notify({
                        Title = "Tpwalk Set",
                        Content = "Tpwalk value set to " .. num,
                        Duration = 3,
                        Image = 4483362458
                    })
                else
                    Rayfield:Notify({
                        Title = "Invalid Value",
                        Content = "Tpwalk value cannot be zero",
                        Duration = 3,
                        Image = 4483362458
                    })
                end
            else
                if num > 0 then
                    tpWalkConfig.value = num
                    Rayfield:Notify({
                        Title = "Tpwalk Set",
                        Content = "Tpwalk value set to " .. num,
                        Duration = 3,
                        Image = 4483362458
                    })
                else
                    Rayfield:Notify({
                        Title = "Invalid Value",
                        Content = "Tpwalk value must be positive",
                        Duration = 3,
                        Image = 4483362458
                    })
                end
            end
        else
            Rayfield:Notify({
                Title = "Invalid Input",
                Content = "Please enter a valid number",
                Duration = 3,
                Image = 4483362458
            })
        end
    end,
})

ScriptTab:CreateToggle({
    Name = "Allow Negative Values",
    CurrentValue = tpWalkConfig.allowNegative,
    Flag = "TpwalkAllowNegative",
    Callback = function(Value)
        tpWalkConfig.allowNegative = Value
        if not Value and tpWalkConfig.value <= 0 then
            tpWalkConfig.value = 1
            Rayfield:Notify({
                Title = "Tpwalk Reset",
                Content = "Tpwalk value reset to 1",
                Duration = 3,
                Image = 4483362458
            })
        end
    end,
})

ScriptTab:CreateToggle({
    Name = "Enable Tpwalk",
    CurrentValue = tpWalkConfig.enabled,
    Flag = "TpwalkToggle",
    Callback = function(Value)
        tpWalkConfig.enabled = Value
    end,
})

local function applyTpWalk()
    if tpWalkConfig.enabled and LocalPlayer.Character then
        local humanoid = LocalPlayer.Character:FindFirstChildOfClass("Humanoid")
        local rootPart = LocalPlayer.Character:FindFirstChild("HumanoidRootPart")
        
        if humanoid and rootPart then
            rootPart.CFrame = rootPart.CFrame + (humanoid.MoveDirection * tpWalkConfig.value)
        end
    end
end

LocalPlayer.CharacterAdded:Connect(function(char)
    char:WaitForChild("Humanoid", 5)
    char:WaitForChild("HumanoidRootPart", 5)
end)

task.spawn(function()
    while true do
        if tpWalkConfig.enabled then
            applyTpWalk()
        end
        task.wait()
    end
end)

-- ESP Tab Controls
EspTab:CreateToggle({
    Name = "Enable ESP",
    CurrentValue = espConfig.enabled,
    Flag = "EspToggle",
    Callback = function(Value)
        espConfig.enabled = Value
        updateAllEsp()
    end,
})

EspTab:CreateDropdown({
    Name = "Exclude Players from ESP",
    Options = getPlayerList(),
    CurrentOption = "",
    MultipleOptions = true,
    Flag = "EspPlayerFilterDropdown",
    Callback = function(Selected)
        espFilters.excludedPlayers = {}
        for _, playerName in ipairs(Selected) do
            espFilters.excludedPlayers[playerName] = true
        end
        updateAllEsp()
    end,
})

EspTab:CreateToggle({
    Name = "Show Player Teams",
    CurrentValue = espConfig.teamEnabled,
    Flag = "TeamEspToggle",
    Callback = function(Value)
        espConfig.teamEnabled = Value
        for player, data in pairs(espData.players) do
            if data.billboard and data.billboard:FindFirstChild("TeamLabel") then
                data.billboard.TeamLabel.Visible = Value
            end
        end
    end,
})

EspTab:CreateToggle({
    Name = "Show Player Names",
    CurrentValue = espConfig.nameEnabled,
    Flag = "NameEspToggle",
    Callback = function(Value)
        espConfig.nameEnabled = Value
        for player, data in pairs(espData.players) do
            if data.billboard and data.billboard:FindFirstChild("NameLabel") then
                data.billboard.NameLabel.Visible = Value
            end
        end
    end,
})

EspTab:CreateToggle({
    Name = "Show Health",
    CurrentValue = espConfig.healthEnabled,
    Flag = "HealthEspToggle",
    Callback = function(Value)
        espConfig.healthEnabled = Value
        for player, data in pairs(espData.players) do
            if data.billboard and data.billboard:FindFirstChild("HealthLabel") then
                data.billboard.HealthLabel.Visible = Value
            end
        end
    end,
})

EspTab:CreateToggle({
    Name = "Highlight Players",
    CurrentValue = espConfig.highlightEnabled,
    Flag = "HighlightEspToggle",
    Callback = function(Value)
        espConfig.highlightEnabled = Value
        for player, data in pairs(espData.players) do
            if data.highlight then
                data.highlight.Enabled = Value
            end
        end
    end,
})

EspTab:CreateToggle({
    Name = "Item ESP",
    CurrentValue = espConfig.itemEspEnabled,
    Flag = "ItemEspToggle",
    Callback = function(Value)
        espConfig.itemEspEnabled = Value
        updateItemEsp()
    end,
})

EspTab:CreateToggle({
    Name = "Show Held Items",
    CurrentValue = espConfig.heldItemEnabled,
    Flag = "HeldItemToggle",
    Callback = function(Value)
        espConfig.heldItemEnabled = Value
        for player, data in pairs(espData.players) do
            if data.billboard and data.billboard:FindFirstChild("HeldItemLabel") then
                data.billboard.HeldItemLabel.Visible = Value
            end
        end
    end,
})

EspTab:CreateColorPicker({
    Name = "Highlight Color",
    Color = espConfig.highlightColor,
    Flag = "HighlightColorPicker",
    Callback = function(Value)
        espConfig.highlightColor = Value
        for player, data in pairs(espData.players) do
            if data.highlight then
                data.highlight.FillColor = Value
                data.highlight.OutlineColor = Value
            end
        end
    end
})

EspTab:CreateColorPicker({
    Name = "Text Color",
    Color = espConfig.textColor,
    Flag = "TextColorPicker",
    Callback = function(Value)
        espConfig.textColor = Value
        for player, data in pairs(espData.players) do
            if data.billboard then
                if data.billboard:FindFirstChild("NameLabel") then
                    data.billboard.NameLabel.TextColor3 = Value
                end
                if data.billboard:FindFirstChild("HealthLabel") then
                    data.billboard.HealthLabel.TextColor3 = Value
                end
            end
        end
    end
})

EspTab:CreateColorPicker({
    Name = "Team Text Color",
    Color = espConfig.teamColor,
    Flag = "TeamColorPicker",
    Callback = function(Value)
        espConfig.teamColor = Value
        for player, data in pairs(espData.players) do
            if data.billboard and data.billboard:FindFirstChild("TeamLabel") then
                data.billboard.TeamLabel.TextColor3 = Value
            end
        end
    end
})

EspTab:CreateColorPicker({
    Name = "Item Color",
    Color = espConfig.itemColor,
    Flag = "ItemColorPicker",
    Callback = function(Value)
        espConfig.itemColor = Value
        for item, itemData in pairs(espData.items) do
            if itemData.highlight then
                itemData.highlight.FillColor = Value
                itemData.highlight.OutlineColor = Value
            end
            if itemData.billboard and itemData.billboard:FindFirstChild("ItemLabel") then
                itemData.billboard.ItemLabel.TextColor3 = Value
            end
        end
    end
})

EspTab:CreateColorPicker({
    Name = "Held Item Color",
    Color = espConfig.heldItemColor,
    Flag = "HeldItemColorPicker",
    Callback = function(Value)
        espConfig.heldItemColor = Value
        for player, data in pairs(espData.players) do
            if data.billboard and data.billboard:FindFirstChild("HeldItemLabel") then
                data.billboard.HeldItemLabel.TextColor3 = Value
            end
        end
    end
})

local itemList = {"Gun", "Sword", "Ammo", "HealthPack", "Coin", "Key", "Armor", "Shield"}

EspTab:CreateDropdown({
    Name = "Tracked Items",
    Options = itemList,
    CurrentOption = espConfig.trackedItems,
    MultipleOptions = true,
    Flag = "TrackedItemsDropdown",
    Callback = function(Selected)
        espConfig.trackedItems = Selected
        
        for item, itemData in pairs(espData.items) do
            if itemData.highlight then itemData.highlight:Destroy() end
            if itemData.billboard then itemData.billboard:Destroy() end
        end
        espData.items = {}
        
        if espConfig.itemEspEnabled and espConfig.enabled then
            updateItemEsp()
        end
    end,
})

EspTab:CreateInput({
    Name = "Add Custom Item",
    PlaceholderText = "Item Name",
    RemoveTextAfterFocusLost = true,
    Callback = function(Text)
        if Text and Text ~= "" then
            local exists = false
            for _, name in ipairs(espConfig.trackedItems) do
                if name:lower() == Text:lower() then
                    exists = true
                    break
                end
            end
            
            if not exists then
                table.insert(espConfig.trackedItems, Text)
                if espConfig.itemEspEnabled and espConfig.enabled then
                    updateItemEsp()
                end
                Rayfield:Notify({
                    Title = "Item Added",
                    Content = "Added '" .. Text .. "' to tracked items",
                    Duration = 3,
                    Image = 4483362458
                })
            else
                Rayfield:Notify({
                    Title = "Item Already Exists",
                    Content = "'" .. Text .. "' is already in tracked items",
                    Duration = 3,
                    Image = 4483362458
                })
            end
        end
    end,
})

-- Credits Tab Content
CreditsTab:CreateSection("Development Team")
CreditsTab:CreateLabel("Lead Developer: Corygunzjr")
CreditsTab:CreateLabel("Ul Framework: Rayfield Interface Suite")

CreditsTab:CreateParagraph({
    Title = "About This Project",
    Content = "Universal Hitbox Expander is designed to work across multiple games with advanced features like team detection, NPC support, ESP, and anti-detection techniques."
})

CreditsTab:CreateSection("Special Thanks to the following")
CreditsTab:CreateLabel("Testing Team: oblivioustb, spzllzk, newdaverepublic")

-- Events
Players.PlayerAdded:Connect(function()
    playerDropdown:Refresh(getPlayerList(), true)
    forceIncludeDropdown:Refresh(getPlayerList(), true)
end)

Players.PlayerRemoving:Connect(function(player)
    if monitoredPlayers[player] then
        local char = player.Character
        if char then
            for _, partsList in pairs(hitboxPartsMap) do
                for _, partName in ipairs(partsList) do
                    local part = char:FindFirstChild(partName)
                    if part then
                        resetPart(part)
                    end
                end
            end
        end
        monitoredPlayers[player] = nil
        visibilityCache[player] = nil
    end
    playerDropdown:Refresh(getPlayerList(), true)
    forceIncludeDropdown:Refresh(getPlayerList(), true)
end)

Teams.ChildAdded:Connect(function()
    teamDropdown:Refresh(getTeamList(), true)
end)

Teams.ChildRemoved:Connect(function()
    teamDropdown:Refresh(getTeamList(), true)
end)

for _, player in ipairs(Players:GetPlayers()) do
    if player ~= LocalPlayer then
        applyHitbox(player)
    end
end

Players.PlayerAdded:Connect(function(player)
    if player ~= LocalPlayer then
        applyHitbox(player)
    end
end)

setupNPCMonitoring()

-- ========================================================================
-- OPTIMIZED HEARTBEAT LOOP WITH OFF-WALL DETECTION (NO DISTANCE LIMITS)
-- ========================================================================
RunService.Heartbeat:Connect(function()
    -- Precompute raycast parameters for this frame
    local camera = Workspace.CurrentCamera
    if not camera then return end
    local origin = camera.CFrame.Position

    -- Update the sharedRaycastParams with the current ignore list
    local ignoreList = {camera}
    if LocalPlayer.Character then
        table.insert(ignoreList, LocalPlayer.Character)
    end
    sharedRaycastParams.FilterDescendantsInstances = ignoreList

    -- Update visibility for players
    for player, _ in pairs(monitoredPlayers) do
        local char = player.Character
        visibilityCache[player] = false
        if char then
            if config.legitMode then
                -- Use off-wall detection (no distance limits)
                visibilityCache[player] = isAnyBodyPartVisible(char, origin, sharedRaycastParams)
            else
                visibilityCache[player] = true
            end
        end
        applyHitbox(player)
    end

    -- Update visibility for NPCs
    for model, _ in pairs(npcTracker.activeNPCs) do
        visibilityCache[model] = false
        if config.legitMode and config.npcEnabled then
            local rootPart = model:FindFirstChild("HumanoidRootPart")
            if rootPart then
                visibilityCache[model] = isPartVisible(rootPart, origin, sharedRaycastParams)
            end
        end
        applyNPCHitbox(model)
    end

    -- Existing ESP and walkspeed code
    if espConfig.enabled then
        updateAllEsp()
    end
    
    if walkspeedConfig.enabled then
        applyWalkspeed()
    end
    
    if tpWalkConfig.enabled then
        applyTpWalk()
    end
end)

task.spawn(function()
    wait(1)
    if Rayfield then
        Rayfield:ShowWindow()
        game:GetService("StarterGui"):SetCore("SendNotification", {
            Title = "Hitbox Expander",
            Text = "Press Right Shift to toggle UI",
            Duration = 5
        })
    end
end)

game:GetService("UserInputService").InputBegan:Connect(function(input, gameProcessed)
    if not gameProcessed and input.KeyCode == Enum.KeyCode.RightShift then
        if Rayfield then
            Rayfield:ToggleWindow()
        end
    end
end)